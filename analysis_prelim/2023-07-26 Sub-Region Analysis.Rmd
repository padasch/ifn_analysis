---
title: "Data Exploration"
author: "Pascal Schneider"
date: "`r Sys.Date()`"
output:
  # html_notebook:
  #   toc: yes
  #   toc_float: yes
  #   number_sections: yes
  html_document:
    toc: yes
    toc_float: yes
    df_print: paged
    number_sections: yes
---

<!-- Making tables searchable: https://holgerbrandl.github.io/r/2015/03/12/sortable-searchable-paginated-tables-with-knitr-and-jquerydatatables.html -->

<link rel="stylesheet" type="text/css" href="http://cdn.datatables.net/1.10.5/css/jquery.dataTables.min.css">

```{=html}
<script src="http://code.jquery.com/jquery-2.1.2.min.js"></script>
```
```{=html}
<script src="http://cdn.datatables.net/1.10.5/js/jquery.dataTables.min.js"></script>
```
```{=html}
<script type="text/javascript">
         $(document).ready(function() {
             $("table").DataTable();
         } );
</script>
```
<!-- Making table searchable END -->

# Load Packages

```{r message=FALSE, warning=FALSE}
source(here::here("R/00-setup.R"))
```

# Loading Data

```{r message=FALSE, warning=FALSE}
raw_metadata <- 
  read_csv2(
    here::here("data/raw/export_dataifn_2005_2021/metadonnees.csv"), 
    skip = 17,    # Skip initial descriptions
    n_max = 163,  # Only load variable descriptions
  ) |> 
  rename(variable = "// Code",
         label = "Libellé",
         description = "Définition") |> 
  arrange(variable)
```

```{r message=FALSE, warning=FALSE}
raw_units <- 
  read_csv2(
    here::here("data/raw/export_dataifn_2005_2021/metadonnees.csv"), 
    skip = 184,    # Skip initial descriptions and metadata
    n_max = 224,  # Only load unit descriptions
    
  ) |> 
  rename(variable = "// Donnée",
         label = "Libellé",
         unit = "Unité",
         campagnes = "Campagnes",
         type = "Type",
         description = "Définition") |> 
  arrange(variable)
```

```{r message=FALSE, warning=FALSE}
raw_lvls <- 
  read_csv2(
    here::here("data/raw/export_dataifn_2005_2021/metadonnees.csv"), 
    skip = 412,    # Skip metadata and units
  ) |> 
  rename(variable = "// Unité",
         label = "Libellé",
         lvl = "Code",
         description = "Définition") |> 
  arrange(variable)
```

```{r message=FALSE, warning=FALSE}
# Load all datafiles into a list
l_raw_data <- list()

# Data directory
dr_data <- here::here("data/raw/export_dataifn_2005_2021/")

for (file in list.files(dr_data, pattern = ".csv", include.dirs = FALSE)){
  
  # Get name and path for data
  name <- file |> stringr::str_to_lower() |> stringr::str_remove(".csv")
  path <- paste0(dr_data, file)
  
  # Skip non-data files
  if (name %in% c("metadonnees", "espar-cdref13")) {next}
  
  # Save data to list
  l_raw_data[[name]] <-
    read_delim(
      path, delim = ";", escape_double = FALSE, trim_ws = TRUE,
      col_types = cols(XL = col_character(),  # Load coordinates as char
                       YL = col_character())  # to avoid automatic rounding
      )
}

# Clean up variable names
l_raw_data <- purrr::map(l_raw_data, ~format_vars(raw_units, .))

# Drop columns with NA only
l_raw_data <- purrr::map(l_raw_data, ~. |> select(where(~!all(is.na(.)))))
```

# Quick Look-up for Variables

## Metadata

```{r}
raw_metadata |> knitr::kable()
```

## Variable Units

```{r}
raw_units |> knitr::kable()
```

## Variable Descriptions

```{r}
# Careful: Very long output, may cause issues
# raw_lvls |> knitr::kable()

raw_lvls |> filter(str_detect(variable, "INCID"))
```

## Extract coordinates

```{r}
# Extract sampling coordinates in Lambert 93 CRS EPSG:2154
coords_l93 <- 
  l_raw_data$placette |> 
  dplyr::select(lon, lat) |> 
  distinct() |> 
  rowid_to_column(var = "id")

# Create simple feature
sf_l93 <- sf::st_as_sf(coords_l93, coords = c("lon", "lat"), crs = 2154)

# Transform to WGS84
coords_wgs84     <- sf::st_transform(sf_l93, crs = 4326)
coords_wgs84$lat_new <- sf::st_coordinates(coords_wgs84)[, "Y"]
coords_wgs84$lon_new <- sf::st_coordinates(coords_wgs84)[, "X"]
coords_wgs84 <- coords_wgs84 |> as_tibble() |> select(id, lat_new, lon_new)

# Get coordinates dictionary
coord_dict <- left_join(coords_l93, coords_wgs84, by = "id") |> select(-id)

# Update location dataframe
l_raw_data$placette <- 
  l_raw_data$placette |> 
  left_join(coord_dict, by = c("lon", "lat")) |> 
  dplyr::rename(lon_fr = lon, lat_fr = lat) |> 
  dplyr::rename(lon = lon_new, lat = lat_new) |> 
  dplyr::mutate(lon = round(lon, 6),
                lat = round(lat, 6))
```

# Data Structure

## Summary

-   Due to the blurring of coordinates, there are distinct sites that were measured in different years but that share the same coordinate. Therefore, aggregating data spatially to the same coordinates merges data from potentially up to four years, which influecnes analysis down-stream.
    -   A potential solution to keep track of the trees is to aggregate trees to the same coordinate and tracking their ids with a variable `idp_a`.
-   Due to different sampling targets of the different campaigns (e.g., only from 2015 onwards, tree diameter was re-measured, which includes recruitment of new trees). Therefore, not all sites before 2010 have revisits.
-   Naturally, sites after 2016 also have no revisits. So, the actual revisit data only goes from 2010 to 2016.
-   I found that there are cases where the first visit was recorded in the location data but not in the tree data. This can be the case, for example, for newly afforesteds areas, where you had no trees at the first visit but many small trees in the second visit. To keep track of this, I must use the location data as primary source of truth for number of visits!

## Revisit Structure

```{r}
# Get temporary df
df_tmp  <- l_raw_data$placette

# Get total number of locations
n_plots <- df_tmp |> pull(idp) |> unique() |> length()

# Get locations with visit == 1
idp_1visit <- df_tmp |> filter(visite == 1) |> pull(idp) |> unique()

# Get locations with visit == 2
idp_2visit <- df_tmp |> filter(visite == 2) |> pull(idp) |> unique()

# Get locations with only a first or only a second visit
n_only_v1  <- df_tmp |> filter(visite == 1, !idp %in% idp_2visit)
n_only_v2  <- df_tmp |> filter(visite == 2, !idp %in% idp_1visit)

# Variables for later use
loc_only_v1 <- n_only_v1
loc_only_v2 <- n_only_v2

# Get table with # of visits and re-visits
tab_visits <- l_raw_data$placette |> pull(visite) |> table()
```

```{r}
# Print results
cat("\n # All entries:  ", n_plots,
    "\n # Entries with visite == 1: ", tab_visits[[1]],
    "\n # Entries with visite == 2: ", tab_visits[[2]],
    "\n   = Revisit rate:  ", round(tab_visits[[2]] / tab_visits[[1]] * 100, 0), "%",
    "\n # Entries without 2nd visit: ", nrow(n_only_v1), 
    "(", round(nrow(n_only_v1) / n_plots * 100, 2), "% )",
    "\n # Entries with only 2nd visit: ", nrow(n_only_v2),
    "(", round(nrow(n_only_v2) / n_plots * 100, 2), "% )")

cat("\n -------------------------------------------------------\n")

# What are the campaigns where only one or only a second visit was entered?
cat("\n > Table of Campagnes of Sites without second visit :\n")
table(n_only_v1$campagne)

cat("\n > Table of Campagnes of Sites with only second visit :\n")
table(n_only_v2$campagne)

cat("\n > Table of Departments of Sites with only second visit :\n")
table(n_only_v2$dep)[table(n_only_v2$dep) > 0]

```

Can we confirm this table with the tree-level data? Note that unlike for the location data, we do not have explicit information on the visit. We only have information on whether a tree was visited once or twice.

```{r}
# Get total number of visits per location
df_all <- 
  l_raw_data$arbre |> 
  select(idp, campagne) |> 
  distinct() |> 
  group_by(idp) |> 
  mutate(visits = n())

n_plots <- nrow(df_all)  
  
# Split dfs into locations with one and two visit(s)
df_v1 <- df_all |> filter(visits == 1)
df_v2 <- df_all |> filter(visits == 2)

# Print results
cat("\n # Entries in total:  ", n_plots,
    "\n # Entries with 1 Visit:  ", nrow(df_v1), 
    " (", round(nrow(df_v1)/n_plots*100) ,"% of total)",
    "\n # Entries with 2 Visits: ", nrow(df_v2), 
    " (", round(nrow(df_v2)/n_plots*100) ,"% of total)")
```

The numbers from the tree-lvl data does not really match the location-lvl data. Looking at the data separately showed that the location and tree data does not align 100%. For example, there are revisits stated in the location data for which there were no tree measurements. Let's dive into this further:

## All possible cases

|Case - Nr.| Case                                                                                     | IDP       |
|----------|------------------------------------------------------------------------------------------|-----------|
| 1        | ONE visit, recorded as `visit == 1` AND tree data from that visit                        | 36942     |
| 4        | ONE visit, recorded as `visit == 2` AND tree data from that visit                        | 605994    |
| 2        | ONE visit, recorded as `visit == 1` AND tree data from two visits                        | NONE      |
| 3        | ONE visit, recorded as `visit == 1` AND NO tree data from that visit                     | 126       |
| 4        | ONE visit, recorded as `visit == 2` AND NO tree data from that visit                     | 10000    |
| 5        | TWO visits with all first trees recorded again AND WITHOUT new trees recruited           | 1106469   |
| 6        | TWO visits with all first trees recorded again AND WITH new trees recruited              | 1125552   |
| 7        | TWO visits with NOT all first-visit-trees recorded again AND WITHOUT new trees recruited | 179       |
| 8        | TWO visits with NOT all first-visit-trees recorded again AND WITH new trees recruited    | NONE      |
| 9        | TWO visits with NO first-visit-trees AND WITH new trees recruited at second visit        | 1100040   |
| 10       | TWO visits with tree data only from first visit                                          | 19        |
| 10       | TWO visits but with no tree data on both visits                                          | 1000482   |

```{r}
# 1 ---
# Get index for counting amount of visits (= is there one or two visits available?)
f_get_n_visits <- function(df_in){

  df_out <- 
    df_in |> 
    select(idp, campagne) |> 
    distinct() |> 
    group_by(idp) |> 
    mutate(n_visits = n()) |> 
    ungroup()
  
  return(df_out)
}

idx_n_visits_loc <- f_get_n_visits(l_raw_data$placette)
idx_n_visits_tre <- f_get_n_visits(l_raw_data$arbre)

idx_counts <- full_join(
  idx_n_visits_tre |> rename(n_visits_tre = n_visits), 
  idx_n_visits_loc |> rename(n_visits_loc = n_visits)
  )

# 2 ---
# Get index with visit number stating repetition of visit
# Reason: Some tree data has only one visit, which is associated with a second
# visit labeling in the location data. These should be removed.

idx_rep_visits_loc <- 
  l_raw_data$placette |> 
  select(idp, campagne, visite) |> 
  rename(visite_loc = visite) |> 
  arrange(idp)

idx_rep_visits_tre <-
  l_raw_data$arbre |> 
  select(idp, campagne) |> 
  distinct() |> 
  arrange(idp, campagne) |> 
  group_by(idp) |> 
  mutate(visite_tre = row_number()) |> 
  ungroup()

idx_labels <- full_join(idx_rep_visits_loc, idx_rep_visits_tre)

# 3 ---
# Combine indexes
idx_comb <- left_join(idx_counts, idx_labels) |> arrange(idp, campagne)

# Display final structure of index
head(idx_comb)
```


```{r}
# Function for easy printing
f_get_rnd_slice <- function(df_in, n = 1) {
  set.seed(1)
  paste0(df_in |> slice_sample(n = n) |> pull(idp))
  }

# Searching for edge cases in number of visits
tmp <- idx_comb |> filter(!is.na(visite_loc))
cat("\n # Site-Years with location data:\t\t\t\t", nrow(tmp),
    "\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(!is.na(visite_tre))
cat("\n # Site-Years with tree data:\t\t\t\t\t", nrow(tmp),
    "\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(n_visits_tre == n_visits_loc)
cat("\n # Site-Years with same #visits for loc and tree:\t\t", nrow(tmp),
    "\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(is.na(visite_tre))
cat("\n # Site-Years visits without tree data:\t\t\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(is.na(visite_loc)) 
cat("\n # Site-Years with tree data and without location data:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

cat("\n ---------------------------------------------------------------------------------------------------------------")

tmp <- idx_comb |> filter(n_visits_tre == 1, n_visits_loc == 1)
cat("\n # Site-Years visited once, and trees recorded once:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(n_visits_tre == 2, n_visits_loc == 1)
cat("\n # Site-Years visited once, and trees recorded twice:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(n_visits_tre == 2, n_visits_loc == 2)
cat("\n # Site-Years visited twice, and trees recorded twice:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(n_visits_tre == 1, n_visits_loc == 2) 
cat("\n # Site-Years visited twice, and trees recorded once:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp, 4))

cat("\n ---------------------------------------------------------------------------------------------------------------")

tmp <- idx_comb |> filter(n_visits_tre == 2, visite_loc == 1)
cat("\n # Site-Years with `visite == 1` but trees recorded twice:\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))

tmp <- idx_comb |> filter(n_visits_loc == 1, visite_loc == 2)
cat("\n # Site-Years with only one visit but `visite == 2`:\t\t", nrow(tmp),
    "\t\t| Sample idp: ", f_get_rnd_slice(tmp))
```

NOTE:
- prelev5 indicates whether ALL trees have been cut at second visit -> then, no trees have been recorded and we can assume all have been removed!!!

```{r}
# Quick access
n <- 771588
l_raw_data$arbre    |> filter(idp == n)
l_raw_data$placette |> filter(idp == n)
```

```{r}
# Get number of visits index
# Taking location data as source of truth for whether the campaign was the first
# or second visit because there might have been no trees recorded in the first 
# visit but newly grown trees in the second visit.
idx_loc <- l_raw_data$placette |> select(idp, campagne, visite)

# Also get a "number of visits" index from the tree data to check for edge cases
idx_tre <- 
  l_raw_data$placette |> 
  select(idp, campagne) |> 
  distinct() |> 
  group_by(idp) |> 
  mutate(n_visits = n()) |> 
  ungroup()

# The code below does the following steps:
# - It joins the visits index to translate the campagne number to the visit nmb 
#   (could also be done through attaching the location information, but then
#   we have the issue of potentially not having two visits but only a false
#   visit = 2 entry).
# - The df is widened to have one row per tree (some variables are needlessly
#   duplicated but this can be cleaned later, see `fixed_vars`)
# - The widened df, is then mutated to count the trees in the first and second
#   visit and to check whether the same amount of trees was sampled, whether
#   some trees were not recorded again in second visit (lost),
#   and whether there were new trees counted in the second visit (= recruitment).

# Define a function to compare nested lists in a dataframe
count_x_not_in_y <- function(x, y){sum(!x %in% y)}

# Define variables that stay fixed (incomplete list for now, 2023-08-03)
fixed_vars <- c("idp", "a")

# Debug: Edge cases to see if code works
edge_cases <- c(19, 1125552, 1100040, 605994, 179, 1106469)

# Wrangle dataframe
df_treecount <-
  l_raw_data$arbre |> 
  right_join(idx_loc, by = c("idp", "campagne")) |> 
  pivot_wider(names_from = visite, values_from = -all_of(fixed_vars)) |> 
  group_by(idp) |> 
  nest() |> 
  
  ## Deubg slices
  ## Specific sites
  # filter(idp == 1100040) |> 
  # filter(idp == 605994) |> 
  # filter(idp == 19) |>
  
  # Edge cases
  # filter(idp %in% edge_cases) |> 
  
  ## Random Subset
  # ungroup() |>
  # slice(as.integer(runif(n=50, min=1, max=100000))) |>
  # group_by(idp) |>
  
  ##
  mutate(trees_v1    = map(data, ~filter(., 
                                         !is.na(campagne_1), 
                                         !is.na(a)) |> pull(a)),
         trees_v2    = map(data, ~filter(., 
                                         !is.na(campagne_2), 
                                         !is.na(a)) |> pull(a)),
         n_trees_v1  = length(unlist(trees_v1)),
         n_trees_v2  = length(unlist(trees_v2)),
         n_missing   = map2_dbl(trees_v1, trees_v2, count_x_not_in_y),
         n_recruited = map2_dbl(trees_v2, trees_v1, count_x_not_in_y)
         # , 
         # campagne_1  = map_dbl(data, 
         #                       ~filter(!is.na(a), 
         #                               !is.na(campagne_1)) |> 
         #                         pull(campagne_2) |> 
         #                         unique()),
         # campagne_2  = map_dbl(data, 
         #                       ~filter(!is.na(a), 
         #                               !is.na(campagne_1)) |> 
         #                         pull(campagne_2) |> 
         #                         unique())
         ) |> 
  select(-trees_v1, -trees_v2) |> 
  ungroup()

head(df_treecount |> arrange(desc(n_recruited)))
```

```{r}
# Sub-sample of only revisited sites and getting metrics
df_2visits <- df_treecount |> filter(!is.na(campagne_1), !is.na(campagne_2))
sum_trees_v1        <- sum(df_2visits$n_trees_v1)
sum_trees_v2        <- sum(df_2visits$n_trees_v2)
sum_trees_missing   <- sum(df_2visits$n_missing)
sum_trees_recruited <- sum(df_2visits$n_recruited)

perc_missing   <- round( sum_trees_missing / sum_trees_v1 * 100)
perc_recruited <- round( sum_trees_recruited / sum_trees_v2 * 100)
```

```{r}
# Print some results
cat("\n Nr. of sites: ", nrow(df_treecount), "( 100 % )",
    "\n  Without revisit: ", nrow(df_treecount |> filter(is.na(campagne_2))),
    "(", round(nrow(df_treecount |> filter(is.na(campagne_2))) / nrow(df_treecount) * 100), "% )", 
    "\n  With    revisit: ", nrow(df_treecount |> filter(!is.na(campagne_2))),
    "(", round(nrow(df_treecount |> filter(!is.na(campagne_2))) / nrow(df_treecount) * 100), "% )",
    "\n --- ",
    "\n From sites that were revisited: ",
    "\n  Nr. of revisited trees: ", sum_trees_v2 - sum_trees_recruited, "( 100 % )",
    "\n  Nr. of trees that went missing: ", sum_trees_missing, "(", perc_missing ,"% )",
    "\n  Nr. of newly recruited trees: ", sum_trees_recruited, "(", perc_recruited ,"% )")
```

```{r}
# From 2nd visits, how often were trees not found anymore?
df_2visits |> 
  select(n_missing, campagne_2) |> 
  group_by(campagne_2) |> 
  summarise(sum_missing = sum(n_missing)) |> 
  ggplot(aes(campagne_2, sum_missing)) +
  geom_point() +
  geom_line() +
  ggtitle(
    paste0("Missing: Numer of trees that were not recorded during 2nd visit: ", 
           sum_trees_missing, " (", perc_missing,"%)")
    )
```

```{r}
# From 2nd visits, how often were new trees recruited?
df_treecount |> 
  filter(!is.na(campagne_2)) |> 
  select(n_recruited, campagne_2) |> 
  group_by(campagne_2) |> 
  summarise(sum_recruited = sum(n_recruited)) |> 
  ggplot(aes(campagne_2, sum_recruited)) +
  geom_point() +
  geom_line() +
  ggtitle(
    paste0("Recruitment: Numer of trees that were newly recorded during 2nd visit: ", 
           sum_trees_recruited, " (", perc_recruited,"%)")
    )
```

```{r}
# Check: Why are there revisited sites in the location data that are not
# in the tree data?

# Look at the time the data comes from
df_tmp <- l_raw_data$placette |> filter(visite == 2)
sites_revisited_only_in_df_loc <- df_tmp |> filter(!idp %in% df_2visits$idp)
hist(sites_revisited_only_in_df_loc$campagne)

sites_revisited_only_in_df_loc


# Sites that have only a second visit in the location data but not in the tree data
table(loc_only_v2$idp %in% df_tmp$idp)
loc_only_v2$idp[!(loc_only_v2$idp %in% df_tmp$idp)]
```

## Sites with identical coordinates

```{r}
# Get a dataframe with all plots that have the same coordinates:
## placette-based
df_xy <-  l_raw_data$placette |> mutate(xy = paste0(lon, "_", lat)) 

# Function to get coordinate dupes per visit
f_get_dupes <- function(
    data, 
    v
    ){
  
  data |>
  filter(visite == !!v) |>  # Filter for sites with a given visit
  select(idp, campagne, visite, lon, lat, xy) |> # Select relevant vars
  distinct() |>             # remove dupes caused form having the same info per tree
  group_by(xy) |>           # Group sites by coordinates
  filter(n()>1) |>          # Keep coordinates with more than one site id
  mutate(n = n(),           # Add counter how often the same coordinate occurs
         id = cur_group_id()) |>  # Add row id per group
  arrange(id, campagne) |>        # Sort df
  ungroup()                 # Remove grouping
}

df_xy_dupes_v1 <- f_get_dupes(df_xy, v = 1)
df_xy_dupes_v2 <- f_get_dupes(df_xy, v = 2)

# Out of all re-visits, how many are from the same location?
frac <- df_xy_dupes_v2 |> nrow() / df_xy |> filter(visite == 2) |> nrow()
cat("\n ", round(frac*100), "% of re-visited location is from the same coordinates.")
```

```{r}
# Get a dataframe with all plots that have the same coordinates: Using tree data

# Get a dataframe with xy coordinates as extra variable, also add visits info
df_xy <-  
  l_raw_data$arbre |> 
  left_join(
    l_raw_data$placette |> 
      select(idp, campagne, visite, lat, lon) |> 
      distinct(),
    by = join_by("idp", "campagne")) |> 
  mutate(xy = paste0(lon, "_", lat)) 

n_xy <- df_xy |> select(idp, campagne, visite, xy) |> distinct() |> nrow()

df_xy_dupes_v1 <- f_get_dupes(df_xy, v = 1)
df_xy_dupes_v2 <- f_get_dupes(df_xy, v = 2)

# Print results
cat("\n # Locations with same coordinates and first visit:  ", nrow(df_xy_dupes_v1),
    " (", round(nrow(df_xy_dupes_v1)/nrow(df_xy) * 100), "%)",
    "\n # Locations with same coordinates and second visit: ", nrow(df_xy_dupes_v2),
    " (", round(nrow(df_xy_dupes_v2)/nrow(df_xy) * 100), "%)")

# Out of all re-visits, how many are from the same location?
frac <- df_xy_dupes_v2 |> nrow() / df_xy |> filter(visite == 2) |> nrow()
cat("\n ", round(frac*100), "% of re-visited location is from the same coordinates.")
```

```{r}
# What are the characteristics of the sites that have the same coordinates?
df_xy_dupes_v1$campagne |> table() |> barplot(main = "Same coordinates: 1 visit",
                                              ylim = c(0, 2000), ylab = "count")
df_xy_dupes_v2$campagne |> table() |> barplot(main = "Same coordinates: 2 visits",
                                              ylim = c(0, 2000), ylab = "count")
```

```{r}
# How often are same-coordinates sites from the same year?
f_same_xy_per_year <- function(df_in, v) {
  df_tmp <- 
    df_in |> 
    group_by(xy) |> 
    nest() |> 
    mutate(n_yr = map_dbl(data, ~pull(., campagne) |> unique() |> length()),
           yrs  = map_chr(
             data, ~pull(., campagne) |> unique() |> paste(collapse = ", ")
             ),
           sites  = map_chr(
             data, ~pull(., idp) |> unique() |> paste(collapse = ", ")
             )
           ) |> 
    arrange(desc(n_yr))

  head(df_tmp)
  tab <- df_tmp$n_yr |> table()
  
  cat("\n > From sites with visit ==", v)

  for (i in 1:length(tab)) {
    cat("\n   ", tab[[i]], "of same-xy sites are from ", i ," year(s).")
  }
  
  return(df_tmp)
}
```

```{r}
# For sites with first visit
df_samexy_per_year_v1 <- f_same_xy_per_year(df_xy_dupes_v1, 1)
head(df_samexy_per_year_v1, n = 10)
tail(df_samexy_per_year_v1, n = 10)
```

```{r}
# For sites with re-visit
df_samexy_per_year_v2 <- f_same_xy_per_year(df_xy_dupes_v2, 2)
tail(df_samexy_per_year_v2, n = 10)
head(df_samexy_per_year_v2, n = 10)
```

```{r}
df_tmp <- 
  df_xy_dupes_v1 |> 
  group_by(xy) |> 
  nest() |> 
  mutate(n_yr = map_dbl(data, ~pull(., campagne) |> unique() |> length()),
         yrs  = map_chr(
           data, ~pull(., campagne) |> unique() |> paste(collapse = ", ")
           )
         ) |> 
  select(-data)

head(df_tmp)

tab_1 <- df_tmp$n_yr |> table()

cat("\n > From sites with visit == 1:")

for (i in 1:length(tab_1)) {
  cat("\n   ", tab_1[[i]], "of same-xy sites are from ", i ," year(s).")
}

df_xy_dupes_v1 |> 
  group_by(campagne, idp, xy) |> 
  nest() |> 
  arrange(xy)

df_xy_dupes_v1 |> 
  select(campagne, idp, xy) |> 
  distinct() |> 
  arrange(xy)
```

# Maps

## France

```{r}
# Next, we build a leaflet map
leaflet() |> 
  # As base maps, use two provided by ESRI
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  # addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") |>
  # addProviderTiles(providers$Esri.WorldTopoMap, group = "World Topo") |>
  
  # Add markers for sampling locations
  leaflet::addMarkers(
    data = l_raw_data$placette,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~as.character(dep),
    clusterOptions = markerClusterOptions()
  )
```

## Sub-Region

```{r}
# Define coordinates for subregion
l_subreg <- list(
  min_lon = 5.542038,
  max_lon = 6.917511,
  min_lat = 45.005973,
  max_lat = 45.556079
)

# Filter sites for subregion
df_loc <- 
  l_raw_data$placette |> 
  dplyr::filter(between(lon, l_subreg$min_lon, l_subreg$max_lon),
                between(lat, l_subreg$min_lat, l_subreg$max_lat))

leaflet() |> 
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  leaflet::addMarkers(
    data = df_loc,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~paste("ID:", idp, "| Campagne:", campagne),
    clusterOptions = markerClusterOptions()
  ) |>
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    fillColor = "transparent"
  )
```

# Analysis of Sub-Region

## Data Filter Criteria

1.  Remove sites that have only a first but no second visit.
2.  Remove sites that have only a second but no first visit

-   or investigate if we can match them)

3.  Remove sites that were sampled twice but where less trees were recorded in the second round.

-   or investigate if trees that were certainly recorded can be matched

## Vegetation State Levels

```{r}
raw_lvls |> 
  filter(str_detect(variable, "^VEGET5")) |> 
  arrange(lvl) |> 
  knitr::kable()
```

TODO: There are no lvls saved for 'VEGET', so I am guessing that those are the same as for 'VEGET5'. However, there is a 'VEGET' = 'Z' for which I cannot find any explanation.

```{r}
lvl_alive <- c("0", "1")
lvl_dead  <- c("2", "5", "A", "C", "M", "T")
lvl_cut   <- c("6", "7")
lvl_na    <- c("N", NA)
```

## Get subset of tree data

```{r}
# For easy access here, get subset again
df_loc <- 
  l_raw_data$placette |> 
  dplyr::filter(
    between(lon, l_subreg$min_lon, l_subreg$max_lon),
    between(lat, l_subreg$min_lat, l_subreg$max_lat)
    )

# Get tree and location dfs
id_subset <- df_loc |> pull(idp)
df_tre    <- 
  l_raw_data$arbre |> 
  filter(idp %in% id_subset)

# Attach status variable
df_tre <- 
  df_tre |> 
  mutate(status  = NA) |> 
  mutate(status5 = NA) |> 
  mutate(
    # First visit
    status  = ifelse(veget  %in% lvl_alive, "0", status),
    status  = ifelse(veget  %in% lvl_dead , "1", status),
    status  = ifelse(veget  %in% lvl_cut  , "2", status),
    status  = ifelse(veget  %in% lvl_na   ,  NA, status),
    
    # Second visit
    status5 = ifelse(veget5 %in% lvl_alive, "0", status5),
    status5 = ifelse(veget5 %in% lvl_dead , "1", status5),
    status5 = ifelse(veget5 %in% lvl_cut  , "2", status5),
    status5 = ifelse(veget5 %in% lvl_na   ,  NA, status5),
    
    # Most recent visit
    status_recent = ifelse(!is.na(status5), status5, status)
  )

# DEBUG FOR SIMPLER DATAFRAMES
df_tre <- df_tre |> select(campagne, idp, a, contains("veget"), contains("status"), c13)
df_loc <- df_loc |> select(campagne, idp, visite, lat, lon)

# Join dataframes
df_join <- 
  left_join(
    df_tre,
    df_loc,
    by = c("campagne", "idp")
  )
```

```{r}
# # Create long-pivot for easier computations
# # 1. Add vis variable for pivot_wide
# df_join <- 
#   df_join |> 
#   mutate(vis = ifelse(visite == 1, paste0("v1"), paste0("v2")))
# 
# # 2. Select variables not to pivot (extendable later on)
# vars_no_pivot <- 
#   c("idp", "vis", "idp", "a",
#     # "lon_fr", "lat_fr", "lon", "lat", 
#     "dep", "ser"
#     )
# 
# vars_to_pivot <- df_join |> select(-all_of(vars_no_pivot)) |> names()
# 
# # Pivot wide
# df_wide <- 
#   df_join |> 
#   pivot_wider(names_from = vis, 
#               values_from = any_of(vars_to_pivot))
# 
# # Drop widened variables that have only NA in them
# df_wide <- df_wide |> select(where(~!all(is.na(.))))

# Aggregate to stand level
# df_stand <- df_wide |> group_by(idp) |> nest()
```

## Current Forest State

Check for the current state of forests (alive/dead/cut). That means, for each of the latest visits of a plot, we want to know its state.

```{r}
# Nest dataframe by site and campaign
df_stand <- df_join |> group_by(idp, campagne) |> nest()

# For each site-campaign, record the most recent tree status
df_agg <- 
  df_stand |> 
  mutate(n_tree = purrr::map_dbl(data, ~nrow(.)),
         agg    = purrr::map(data, 
                             ~. |> 
                               group_by(status_recent) |> 
                               count() |> 
                               pivot_wider(names_from = status_recent, 
                                           values_from = n))
         ) |> 
  unnest(agg) |> 
  rename(
    n_alive = `0`,
    n_dead  = `1`,
    n_cut   = `2`,
    n_na    = `NA`,
  ) 

# For each site-campaign, calculate the percentage of tree status
# Set sites with NA values to 0 because it meant that there was no count.
df_agg <- 
  df_agg |> 
  mutate(
    perc_alive = n_alive / n_tree, 
    perc_dead  = n_dead  / n_tree, 
    perc_cut   = n_cut   / n_tree,   
    perc_na    = n_na    / n_tree   
  ) |> 
  mutate(
    across(contains("n_"), ~ifelse(is.na(.), 0, .)),
    across(contains("perc_"), ~ifelse(is.na(.), 0, .)))

# Quality control: All percentages should equal 1 (with small rounding error)
qc_check <- 
  df_agg |> 
  mutate(qc = perc_alive + perc_dead + perc_na + perc_cut,
         qc = round(qc, 3)) |> 
  filter(qc != 1) |> 
  nrow()

if (qc_check != 0) {stop("QC for tree percentages failed!")}

# For re-visits, keep only the latest data
df_status <- 
  df_agg |>
  ungroup() |>
  select(campagne, idp, contains("perc")) |>
  pivot_longer(cols = contains("perc"), 
               names_to = "status", 
               values_to = "perc") |>
  arrange(desc(campagne), desc(perc)) |>
  group_by(idp) |>
  slice(1) |>
  mutate(status = str_remove(status, "perc_"),
         status = as.factor(status)) |> 
  ungroup()

# Attach coordinates
df_status <- 
  df_status |>
  left_join(df_loc |> select(idp, lat, lon) |> distinct(), by = "idp")
```

## Forest State of Subset

```{r}
# Code adapted from: 
# https://stackoverflow.com/questions/35921590/leaflet-on-r-how-to-create-layers-and-colors-for-each-factor-level-in-dataframe

groups     <-  as.character(unique(df_status$status))
groups_col <-  colorFactor(palette = "viridis", 
                           domain = df_status$status)

map <- 
  leaflet(df_status) |> 
  addProviderTiles(
    providers$Esri.WorldImagery,
    group = "World Imagery") |>
  addProviderTiles(
    providers$Esri.WorldTopoMap, 
    group = "World Topo")

for (g in groups){
  df_i <-  df_status |> filter(status == g)
  
  map <- 
    map |> 
    addCircleMarkers(
      data = df_i, 
      lng = ~lon, 
      lat = ~lat, 
      color = ~groups_col(status),
      group = g, 
      label = ~paste("Status: ", status, 
                     "| Year: ", campagne,
                     "| Perc.: ", round(perc, 2),
                     "| IDP: ", idp),
      opacity = 0.9)

}

map |> 
  addLayersControl(
    overlayGroups = groups,
    baseGroups = c("World Imagery", "World Topo"),
    position = "topleft",
    options = layersControlOptions(collapsed = FALSE)) |> 
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    color = "black",
    fillColor = "transparent",
    opacity = 1
  ) |> 
  addLegend(
    pal = groups_col,
    values = groups,
    title = "Stand Status",
    position = "topleft")
```

IDP: 23803 XL 685643.6379000925 YL 6760725.288768466

IDP: 519963 XL 988815.4102918436 YL 6458378.306485492

```{r}
leaflet() |> 
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  leaflet::addMarkers(
    data = df_status,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~paste("Status:", status, "| Perc.:", round(perc, 2)),
    group = ~status
    # clusterOptions = markerClusterOptions()
  ) |>
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    fillColor = "transparent"
  )
```

```{r}
# DROPPED: 2023-07-28 Worked on getting the forest state from the wide df
# but the realised than not widening might be easier...
# Attach number of trees visited at first and at second visit
df_tmp <- 
  df_stand |> 
  dplyr::mutate(
    ntree_v1 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v1)))),
    ntree_v2 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v2))))
  )

# Get subset with and without revisits WORKING: SEE END OF THIS CHUNK FIRST 
# df_revisit_yes <- df_tmp |> filter(ntree_v2 != 0)
# df_revisit_no  <- df_tmp |> filter(ntree_v2 == 0)

# Filter the weird case, 
df_revisit_yes <- df_tmp |> filter(ntree_v2 != 0)
df_revisit_no  <- df_tmp |> filter(ntree_v2 == 0)
df_revisit_par <- df_tmp |> filter(between(ntree_v2, 1, ntree_v1-1))

# At each site, extract status information from latest visit
df_revisit_yes <- 
  df_revisit_yes |> 
  mutate(n_alive = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 0))),
         n_dead  = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 1))),
         n_cut   = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 2))),
         n_na    = purrr::map_dbl(data, ~nrow(filter(., is.na(status_v2)))),
         p_alive = n_alive / ntree_v2,
         p_dead  = n_dead  / ntree_v2,
         p_cut   = n_cut   / ntree_v2,
         p_na    = n_na    / ntree_v2
         )

df_revisit_no <- 
  df_revisit_no |> 
  mutate(n_alive = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 0))),
         n_dead  = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 1))),
         n_cut   = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 2))),
         n_na    = purrr::map_dbl(data, ~nrow(filter(., is.na(status_v1)))),
         p_alive = n_alive / ntree_v1,
         p_dead  = n_dead  / ntree_v1,
         p_cut   = n_cut   / ntree_v1,
         p_na    = n_na    / ntree_v1
         )

# Investigate plots where there have been more trees visited at the first
# than at the second visit -> that should not be the case!
xxx <- 
  df_revisit_yes |> 
  filter(ntree_v1 > ntree_v2) |> 
  mutate(
    yr1 = purrr::map_dbl(
      data, ~filter(., !is.na(campagne_v1)) |> pull(campagne_v1) |> unique()),
    yr2 = purrr::map_dbl(
      data, ~filter(., !is.na(campagne_v2)) |> pull(campagne_v2) |> unique())
  )
```

## Quality Control of Subset

```{r}
# 1. Check for stands that have not been revisited, where ntree_v2 == 0
df_no_revisit <- df_stand |> filter(ntree_v2 == 0)

# Since all trees are re-visited, there should never be more trees recorded
# in the first visit than in the second visit. Let's see if this is the case:
df_qc <- 
  df_stand |> 
  mutate(qc = ntree_v1/ntree_v2) |> 
  filter(qc > 1)

df_qc
```

## Tree State Percentages

TODO: Question. What about trees that have been dead at the first visit already?

TODO: What about a change in mortality? Then, I would need to have the perc_dead in the first visit and the per_dead in the second visit, right?

TODO: Probably have to add some quality control to filter out plots that were visited only once.

TODO: I am a bit confused about how the counting should were in such temporal data. For example, if a new tree grows. Then in the old plot there were 10 and now 11. So, there is an increase in 10%. But, if another tree died, there is a growth of 10%, a decline of 10%, and no change in the number of trees.

Method:

-   Percentage at first visit: Calculate all trees

```{r}
xxx <- 
  df_stand |> 
  dplyr::mutate(
    ntree_v1 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v1)))),
    ntree_v2 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v2))))
  )



xxx <- 
  df_stand |> 
  dplyr::mutate(
    
    # MORTALITY
    perc_dead_v1 = purrr::map_dbl(
      data,
      ~nrow(filter(., status_v1 == 1 & !is.na(campagne_v1))) / 
        nrow(filter(., !is.na(campagne_v1))))
      ),
    perc_dead_v2 = purrr::map_dbl(
      data,
      ~nrow(filter(., status_v2 == 1))/ nrow()
      ),
    
    # REMOVAL / CUT
    perc_rem_v1 = purrr::map_dbl(
      data,
      ~filter(., status_v1 == 2) |> nrow() / nrow(.)
      ),
    perc_rem_v2 = purrr::map_dbl(
      data,
      ~filter(., status5_v2 == 2) |> nrow() / nrow(.)
      ),
    
    # ALIVE
    perc_rem_v1 = purrr::map_dbl(
      data,
      ~filter(., status_v1 == 2) |> nrow() / nrow(.)
      ),
    perc_rem_v2 = purrr::map_dbl(
      data,
      ~filter(., status5_v2 == 2) |> nrow() / nrow(.)
      ),
  )
```

## Tree Mortality and Removal

### Tree Mortality

```{r}
# 
```

```{r}
xxx <- df_tre$data[[999]]
x   <- xxx |> select(-campagne, -a) |> names()

yyy <- xxx |> pivot_longer(
  cols = all_of(x),
  
)
```

## Forest Growth

## *Definition of Forest Growth:*

### Revisited Trees

```{r}

```

### New Recruitment

```{r}


```
