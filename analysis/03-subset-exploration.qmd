---
title: "Subset Exploration"
---

```{r message=FALSE, warning=FALSE}
source(here::here("R/00-setup.R"))
```

## Summary

-   For this subset analysis, we will focus only on sites that were revisited and that have explicit information on the change in circumference (re-measured circumference or indicator why circumference was not re-measured).

## Set Classification Criteria

```{r}
# Classification of Tree Status 
# Primarily taken by VEGET Variable
code_veget5 <- 
  tibble(
    "0"  = "alive",
    "1"  = "alive",
    "2"  = "dead",
    "5"  = "dead",
    "A"  = "dead",
    "C"  = "dead",
    "M"  = "dead",
    "T"  = "dead",
    "6"  = "cut",
    "7"  = "cut",
    "N"  = NA,
    "NA" = NA
  ) |> 
    pivot_longer(everything(),
                 names_to = "lvl",
                 values_to = "tree_status") |> 
  mutate(lvl = as.factor(lvl),
         tree_status = as.factor(tree_status))

# Classification for human influence

# Classification for natural influence

```

## Create Subsets

### Get tree all tree data indexed

```{r}
# Get raw data
data <- f_get_raw_data_list()
l_raw_data <- data[[1]]
l_metadata <- data[[2]]

# Wrangle coordinates
l_raw_data$placette <- f_attach_wgs_coords_to_raw_placette(l_raw_data$placette)

# Get location index
# idx_loc  <- f_get_location_index(l_raw_data)
idx_tre  <- f_get_tree_index(l_raw_data)
# idx_comb <- left_join(idx_tre, idx_loc, by = "idp")

# Get tree dataframe and attach indeces
df_treid <- 
  l_raw_data$arbre |>
  left_join(idx_tre, by = join_by(idp, a)) |> 
  mutate(
    tree_id  = paste0(idp, "_", a),
    visit_nr = NA,
    visit_nr = ifelse(revisit_state == "revisited" & campagne == visit_1, 1, visit_nr),
    visit_nr = ifelse(revisit_state == "revisited" & campagne == visit_2, 2, visit_nr),
    visit_nr = ifelse(revisit_state == "not_revisited", 1, visit_nr),
    visit_nr = ifelse(revisit_state == "newly_sampled", 2, visit_nr)
    ) |>
  relocate(idp, a, tree_id, campagne, visit_nr,
           visit_1, visit_2, revisit_state, veget, 
           veget5, where(is.numeric))

# Attach information on vegetation state
df_treid <- 
  df_treid |> 
  left_join(code_veget5 |> rename(veget = lvl),
            by = join_by(veget)) |> 
  left_join(code_veget5 |> rename(veget5 = lvl,
                                  tree_status5 = tree_status),
            by = join_by(veget5))
```

```{r}
df_loc_wide <- f_widen_location_data(l_raw_data$placette)
```

### Filter for first visits 2010 or after

```{r}
# Filter for trees that were visited the first time from 2010 onwards
# meaning the second visit was in 2015.
df_subset <- 
  df_treid |> 
  filter(
    visit_2 > 2014,
    (revisit_state == "newly_sampled" |
       revisit_state == "revisited")
    )

# Make df wide
vars_location_tree <- f_get_fixed_vars_per_level(level = "location_tree")
vars_to_keep       <- df_subset |> select( any_of(vars_location_tree)) |>  names()
vars_to_widen      <- df_subset |> select(-any_of(vars_location_tree)) |>  names()

df_wide <- 
  df_subset |> 
  # arrange(tree_id) |> slice(1:1000) |> 
  pivot_wider(
    id_cols = vars_to_keep,
    names_from  = visit_nr,
    values_from = vars_to_widen) |> 
  select(-where(~all(is.na(.))))

# For trees that were sampled the first time in the second campaign, there is 
# the variable veget_2 included (state of vegetation at first sight but second
# sampling campaign). This information can be simply merged into veget_1 without
# loosing information. Also overwrite the state variable for second visit to be 
# the same as for the first visit because, there will be no second visit, and it
# is the latest knowledge on the state. 
# The same applies for "tree_status" variable.
for (i in 1:nrow(df_wide)) {
  if (df_wide$revisit_state[i] == "newly_sampled") {
    df_wide$veget_1[i]        <- df_wide$veget_2[i]
    df_wide$veget5_2[i]       <- df_wide$veget_2[i]
    df_wide$tree_status_1[i]  <- df_wide$tree_status_2[i]
    df_wide$tree_status5_2[i] <- df_wide$tree_status_2[i]
  }
}

df_wide_fin <- 
  df_wide |> 
  select(-veget_2, -tree_status_2) |> 
  rename_with(~ gsub("_1$", "_v1", .), ends_with("_1")) |>
  rename_with(~ gsub("_2$", "_v2", .), ends_with("_2")) |> 
  rename(veget_v2 = veget5_v2,
         tree_status_v2 = tree_status5_v2)

# Attach location data and keep only relevant variables
irr_vars <- f_get_list_of_irrelevant_vars()
irr_vars <- c(irr_vars, paste0(irr_vars, "_v2"))

# Clean up dataframe and calculate change in c13
df_comb <- 
  left_join(df_wide_fin, 
            df_loc_wide,
            by = join_by(idp)) |> 
  select(-any_of(irr_vars)) |> 
  mutate(d_c13 = c13_v2 - c13_v1)

# Split dataset into re-measured and not re-remeasured
df_measured_1  <- df_comb |> filter( is.na(d_c13)) 
df_measured_2  <- df_comb |> filter(!is.na(d_c13)) 
```

### Wrangle data with only one c13 measurement

#### Trees that were re-visited but not re-measured

TODO: What should be done with the not re-measured trees that were alive or dead?

```{r}
# For trees that were cut at revisit
df_tmp <- 
  df_measured_1 |> 
  filter(revisit_state == "revisited") 

# Set change in c13 at second visit to zero and add 
# to dataframe with two c13 measuremnts
df_attach_cutted_trees <- 
  df_tmp |> 
  filter(tree_status_v2 == "cut" |
         tree_status_v2 == "dead") |> 
  mutate(
    c13_v2 = 0,
    d_c13 = c13_v2 - c13_v1
    )

# Quality controls
df_tmp$tree_status_v2 |> table()
df_attach_cutted_trees$tree_status_v2 |> table()
```

#### Trees that were newly recruited
```{r}
# Get dataframe for newly grown trees
df_tmp <- 
  df_measured_1 |> 
  filter(revisit_state == "newly_sampled") 

# Set change in c13 at second visit to zero and add 
# to dataframe with two c13 measuremnts
df_attach_new_trees <- 
  df_tmp |> 
  mutate(
    c13_v1 = 0,
    d_c13 = c13_v2 - c13_v1
    )

# Quality controls
df_tmp$tree_status_v1 |> table()
df_attach_new_trees$tree_status_v1 |> table()
```

### Create final subset df

```{r}
df_measured_2_ext <- 
  rbind(df_measured_2,
        df_attach_cutted_trees,
        df_attach_new_trees)

# Check that no tree is doubled:
qc <- df_measured_2_ext |> pull(tree_id) |> duplicated() |> all()
if (qc) stop("Duplicated trees in the dataset!")
```

## Subset Plots

### Leaflet
```{r}
# Code adapted from: 
# https://stackoverflow.com/questions/35921590/leaflet-on-r-how-to-create-layers-and-colors-for-each-factor-level-in-dataframe

# Define coordinates for subregion
l_subreg <- list(
  min_lon = 5.542038,
  max_lon = 6.917511,
  min_lat = 45.005973,
  max_lat = 45.556079
)

# Get dataframe of interest:
# df_tmp <- 
#   df_measured_2_ext |>
  

df_tmp <- 
  df_measured_2_ext |> 
  dplyr::filter(between(lon, l_subreg$min_lon, l_subreg$max_lon),
                between(lat, l_subreg$min_lat, l_subreg$max_lat)) |> 
   select(idp, visit_v1, visit_v2, d_c13, tree_status_v2, lat, lon)

df_map <- 
  df_tmp |> 
  nest(data = c(tree_status_v2, d_c13, visit_v1)) |> 
  mutate(
    d_c13   = map_dbl(data, ~mean(.$d_c13)),
    n_trees = map_dbl(data, ~nrow(.)),
    n_dead  = map_dbl(data, ~nrow(filter(., tree_status_v2 == "dead"))),
    n_alive  = map_dbl(data, ~nrow(filter(., tree_status_v2 == "alive"))),
    n_cut  = map_dbl(data, ~nrow(filter(., tree_status_v2 == "cut"))),
    perc_dead  = round(n_dead  / n_trees * 100),
    perc_alive = round(n_alive / n_trees * 100),
    perc_cut   = round(n_cut   / n_trees * 100),
    stand_status = case_when(
                              n_alive > n_cut & n_alive > n_dead ~ "alive",
                              n_cut > n_alive & n_cut > n_dead ~ "cut",
                              n_dead > n_alive & n_dead > n_cut ~ "dead",
                              TRUE ~ "equal"),
         stand_status = as.factor(stand_status)
  )

# Avoid overlaps
df_map$lat <- jitter(df_map$lat, factor = 0.0001)
df_map$lon <- jitter(df_map$lon, factor = 0.0001)

# Define groups for plotting
groups     <-  as.character(unique(df_map$stand_status))
groups_col <-  colorFactor(palette = "viridis", 
                           domain = df_map$stand_status)
map <- 
  leaflet(df_map) |> 
  addProviderTiles(
    providers$Esri.WorldImagery,
    group = "World Imagery") |>
  addProviderTiles(
    providers$Esri.WorldTopoMap, 
    group = "World Topo")

for (g in groups) {
  df_i <-  df_map |> filter(stand_status == g)
  
  map <- 
    map |> 
    addCircleMarkers(
    # addMarkers(
      data = df_i, 
      lng = ~lon, 
      lat = ~lat, 
      color = ~groups_col(stand_status),
      group = g, 
      label = ~paste("Plot ID:", idp,
                     "| 2nd visit: ", visit_v2,
                     "| Stand Status: ", stand_status,
                     "| d c13: ", round(d_c13, 3),
                     "| Trees alive: ", round(n_alive/n_trees * 100), "%",
                     "| Trees dead: ", round(n_cut/n_trees * 100), "%",
                     "| Trees cut: ", round(n_dead/n_trees * 100), "%"),
      opacity = 0.9)
}

map |> 
  addLayersControl(
    overlayGroups = groups,
    baseGroups = c("World Imagery", "World Topo"),
    position = "topleft",
    options = layersControlOptions(collapsed = FALSE)) |> 
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    fillColor = "transparent"
  ) |> 
  addLegend(
    pal = groups_col,
    values = groups,
    title = "Stand Status",
    position = "topleft")
```


### Change in c13
```{r}
#| layout-nrow: 1
data <- data.frame(
  lon = df_measured_2_ext$lon,  # Your longitude values
  lat = df_measured_2_ext$lat,   # Your latitude values
  value = df_measured_2_ext$d_c13       # Your value data
)

n_breaks <- 100

mean_values <- 
  aggregate(
    value ~ cut(lon, breaks = n_breaks) + cut(lat, breaks = n_breaks), 
    data, 
    mean)

colnames(mean_values) <- c("lon", "lat", "value")

ggplot() +
  geom_tile(data = mean_values, aes(x = lon, y = lat, fill = value)) +
  # scale_fill_viridis_c(option = "magma") +
  scico::scale_fill_scico(
    palette = "vikO",
    limits = c(-4, 4)
    ) +
  labs(title = "Change in c13 from 2010-2020",
       caption = "Subset from revisited sites from 2010 onwards. Shown are mean values of binned trees",
       fill  = "Average change in c13 from 2010-2020 [m]: \n") +
  theme_void() +
  coord_fixed(ratio = 1.3) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = .6),
        plot.subtitle = element_text(hjust = .6),
        plot.caption = element_text(hjust = .6),
        panel.grid = element_blank())

p1 <- 
  ggplot() +
  geom_histogram(data = data, aes(x = value), bins = 250) +
  labs(title = "Counts of delta c13",
       x = "delta c13") +
  geom_vline(xintercept = 0, color = "red") +
  xlim(-3, 2) +
  theme_classic()

p2 <- 
  ggplot() +
  geom_histogram(data = mean_values, aes(x = value), bins = 1000) +
  geom_vline(xintercept = 0, color = "red") +
  labs(subtitle = "Mean values plotted in the map",
       y = NULL,
       x = NULL)  +
  theme_classic()

p1 + inset_element(p2, 0.1, 0.5, 0.5, 0.95)
```

**Locations where trees shrank**

```{r}
#| layout-nrow: 1
#| layout-col: 2

data <- 
  df_measured_2_ext |> 
  select(lon, lat, d_c13) |> 
  rename(value = d_c13) |> 
  filter(value < 0) |> 
  data.frame()

n_breaks <- 100

mean_values <- 
  aggregate(
    value ~ cut(lon, breaks = n_breaks) + cut(lat, breaks = n_breaks), 
    data, 
    mean)

colnames(mean_values) <- c("lon", "lat", "value")

ggplot() +
  geom_tile(data = mean_values, aes(x = lon, y = lat, fill = value)) +
  scale_fill_gradientn(colors = rev(RColorBrewer::brewer.pal(5, "Reds"))) +
  labs(title = "Decrease in c13 from 2010-2020",
       caption = "Subset from revisited sites from 2010 onwards. Shown are mean values of binned trees",
       fill  = "Average change in c13 from 2010-2020 [m]: \n") +
  theme_void() +
  coord_fixed(ratio = 1.3) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = .6),
        plot.subtitle = element_text(hjust = .6),
        panel.grid = element_blank())
```

```{r}
#| layout-nrow: 1
#| 
## Locations where trees grew
data <- df_measured_2_ext |> 
  select(lon, lat, d_c13) |> 
  rename(value = d_c13) |> 
  filter(value > 0) |> 
  data.frame()

n_breaks <- 100

mean_values <- 
  aggregate(
    value ~ cut(lon, breaks = n_breaks) + cut(lat, breaks = n_breaks), 
    data, 
    mean)

colnames(mean_values) <- c("lon", "lat", "value")

ggplot() +
  geom_tile(data = mean_values, aes(x = lon, y = lat, fill = value)) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(5, "Blues")) +
  labs(title = "Increase in c13 from 2010-2020 (growth and new trees)",
       caption = "Subset from revisited sites from 2010 onwards. Shown are mean values of binned trees",
       fill  = "Average change in c13 from 2010-2020 [m]: \n") +
  theme_void() +
  coord_fixed(ratio = 1.3) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = .6),
        plot.subtitle = element_text(hjust = .6),
        panel.grid = element_blank())


## Locations where NEW trees grew
data <- 
  df_measured_2_ext |> 
  filter(revisit_state == "newly_sampled") |> 
  select(lon, lat, d_c13) |> 
  rename(value = d_c13) |> 
  filter(value > 0) |> 
  data.frame()

n_breaks <- 100

mean_values <- 
  aggregate(
    value ~ cut(lon, breaks = n_breaks) + cut(lat, breaks = n_breaks), 
    data, 
    mean)

colnames(mean_values) <- c("lon", "lat", "value")

ggplot() +
  geom_tile(data = mean_values, aes(x = lon, y = lat, fill = value)) +
  scale_fill_gradientn(colors = RColorBrewer::brewer.pal(5, "Blues")) +
  labs(title   = "Increase in c13 from 2010-2020 (new trees only)",
       caption = "Subset from revisited sites from 2010 onwards. Shown are mean values of binned trees",
       fill    = "Average change in c13 from 2010-2020 [m]: \n") +
  theme_void() +
  coord_fixed(ratio = 1.3) +
  theme(legend.position = "bottom",
        plot.title = element_text(hjust = .6),
        plot.subtitle = element_text(hjust = .6),
        panel.grid = element_blank())
```


```{r}
knitr::knit_exit()
```

# Subset Analysis

# NO RENDER BELOW ---

## Get Clean Dataset

### Load Data

```{r}
# Get raw data
data <- f_get_raw_data_list()
l_raw_data <- data[[1]]
l_metadata <- data[[2]]

# Wrangle coordinates
l_raw_data$placette <- f_attach_wgs_coords_to_raw_placette(l_raw_data$placette)

# Get location index
index <- f_get_location_index(l_raw_data)
```

### Filter Data

Keep only sites that were visited twice and for which there is tree data.

```{r}
index_subset <- index |> filter(n_visits_loc == 2, n_visits_tre != 0)
```

Some sites might have only recorded tree data once during two visits. Reasons are:

-   Old re-visiting strategy (revisits up to 2014) did not re-measure each tree but only gave general assessment of state of plot. Where the entire plot was affected by the same change (no change, removal, mortality), there was only a remark made in the location data.

-   New re-visiting strategy also focused on sampling new trees that were not there during the first visit.

```{r}
# Get sites for which there was no tree data recorded at second visit
df_tmp <- 
  l_raw_data$arbre |> 
  inner_join(index_subset, by = c("idp")) |> 
  filter(n_visits_tre == 1) |> 
  select(idp, campagne, v1, v2) |> 
  rename(yr_tree_visit = campagne) |>  
  distinct()

df_new_trees   <- df_tmp |> filter(yr_tree_visit == v2)
df_old_method  <- df_tmp |> filter(yr_tree_visit == v1)
```

We want to focus on attaching the state of change for each tree that has not been re-measured during the second visit. For this, we use the information given in the location data on the second visit.

Notes:

-   In most cases, there was no change in tree cover. But in a few cases, we have information that there was an incident that affected the tree cover (given by `incid`) but there is no information on the type of incident (given by `nincid`).

```{r}
df_tre <- 
  l_raw_data$arbre |> 
  filter(idp %in% df_old_method$idp) |> 
  select(where(~!all(is.na(.)))) # drop all columns with NA

df_loc <- 
  l_raw_data$placette |> 
  filter(idp %in% df_old_method$idp,
         visite == 2) |> 
  select(where(~!all(is.na(.)))) # drop all columns with NA

cat("Variables with information on second visit: ", paste0(names(df_loc), collapse = ", "))

```

```{r}
#| layout-nrow: 1
df_loc$incid   |> table() |> barplot(main = "Count of incid",
                                     sub  = "Indicator characterizing the intensity of the incident occurring\nin the last 5 years on the point")
df_loc$prelev5 |> table() |> barplot(main = "Count of prelev5",
                                     sub  = "Indicator indicating the presence of a partial (1) or total (2) cutting\nof the trees surveyed during the 1st visit")
```

```{r}
sites_without_change <- df_loc |> filter(prelev5 == 0, incid == 0)
```

```{r}
sites_fully_cut <- df_loc |> filter(prelev5 == 2)
sites_fully_cut$incid   |> table() |> barplot(main = "Count of incid")
```

```{r}
sites_partially_cut  <- df_loc |> filter(prelev5 == 1)
```

### Clean Data

-   Certain sites in the old sampling scheme

-   For sites from 2005-2014, we have no re-meausrement of the C13 data. Thus, we have to use the location data to see whether these trees were still standing or not, and coalesce the data to a common format where we have two-recordings per tree, indicating whether it was removed, dead, cut at the second visit.

-   Some trees measured in 2005 were actually revisited and each tree's vegetation state was recorded. BUT some trees were not explicitly revisited but just note down as the location being cut, partially cut, not cut.

## Map
