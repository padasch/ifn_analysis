---
title: "Data Exploration"
---

## Load Packages

```{r message=FALSE, warning=FALSE}
source(here::here("R/_setup.R"))
```

## Loading Data

```{r}
data <- f_get_raw_data_list()
l_raw_data <- data[[1]]
l_metadata <- data[[2]]
```

### Wrangle coordinates

```{r}
l_raw_data$placette <- f_attach_wgs_coords_to_raw_placette(l_raw_data$placette)
```

## Variable Metadata

### List of Variables

```{r}
lapply(l_raw_data, function(x) toupper(names(x)))
```

### Look-Up Tables

```{r}
#| layout-nrow: 2
DT::datatable(l_metadata$metadata, options = list(pageLength = 10))
DT::datatable(l_metadata$lvls, options = list(pageLength = 10))
DT::datatable(l_metadata$units, options = list(pageLength = 10))
```

## Data Exploration

### Summary

-   Due to the blurring of coordinates, there are distinct sites that were measured in different years but that share the same coordinate. Therefore, aggregating data spatially to the same coordinates merges data from potentially up to four years, which influences analysis down-stream.
    -   A potential solution to keep track of the trees is to aggregate trees to the same coordinate and tracking their ids with a variable `idp_a`.
-   Due to different sampling targets of the different campaigns (e.g., only from 2015 onwards, tree diameter was re-measured, which includes recruitment of new trees). Therefore, not all sites before 2010 have revisits.
-   Naturally, sites after 2016 also have no revisits. So, the actual revisit data only goes from 2010 to 2016.
-   I found that there are cases where the first visit was recorded in the location data but not in the tree data. This can be the case, for example, for newly afforesteds areas, where you had no trees at the first visit but many small trees in the second visit. To keep track of this, I must use the location data as primary source of truth for number of visits!

+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
| Group                         | Number of Visits | Number of Tree Recordings | Description                                                                                              | \# of sites (all sites = 108'873) |
+===============================+==================+===========================+==========================================================================================================+===================================+
| Locations without tree data   | 2                | 0                         | Sites that have been visited twice but no tree data recorded. Could be resampling of grasslands?         | 1'425                             |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               | 1 (first only)   | 0                         | Sites sampled after 2017 that had no revisit yet and were treeless.                                      | 4'481                             |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               | 1 (second only)  | 0                         | Makes no sense                                                                                           | 43                                |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
| Locations with only one visit | 1 (first only)   | 1                         | After 2017, not yet revisited.                                                                           | 27'058                            |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               |                  |                           | Before 2017, no more revisited (**unclear** why)                                                         | 4135                              |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               | 1 (second only)  | 1                         | **Unclear** why location data was only recorded once.                                                    | 89                                |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               | 1                | 2                         | Two tree measurements but only one location measurement                                                  | 0                                 |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
| Locations with two visits     | 2                | 1                         | First visits from 2005-2009 have only one tree measurement and only a general re-assessment of the site. | 25'591                            |
|                               |                  |                           |                                                                                                          |                                   |
|                               |                  |                           | First visits from 2010 on: No trees at first visit but at second visit (recruitment?)                    |                                   |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+
|                               | 2                | 2                         | Standard case for sites with second visit after 2010                                                     | 46'051                            |
+-------------------------------+------------------+---------------------------+----------------------------------------------------------------------------------------------------------+-----------------------------------+

### Figures

```{r warning=FALSE, fig.height=10, fig.width=10}
plot_histograms <- function(df_in){
  nam <- names(df_in) 
  
  df_num <- df_in |> select_if(is.numeric)
  if (ncol(df_num) > 0) {df_num <- df_num |> pivot_longer(cols = everything())}
  
  df_fac <- df_in |> select_if(is.factor)
  if (ncol(df_fac) > 0) {
    fact_vars   <- names(df_fac) |> unique()
    n_fact_vars <- length(fact_vars)
    df_fac <- df_fac |> pivot_longer(cols = everything())
  } else {
    fact_vars   <- ""
    n_fact_vars <- 0
  }
  
  # List of plots
  numeric_plots <- list()
  factor_plots <- list()
  
  # Counter for omitted variables
  vars_removed <- 0

  # Define display thresholds for categorical variables
  na_thr <- 0.75
  n_lvls <- 12
  
  for (var in nam) {
    
    if (var %in% unique(df_num$name)) {
    
      numeric_plots[[var]] <-  
        df_num |> 
        filter(name == var) |> 
        ggplot(aes(x = value)) +
        geom_histogram(bins = 50) + 
        xlab(paste(var)) +
        ylab(NULL)
      
    }
    
    if (var %in% unique(df_fac$name)) {
    
      # Aggregate data
      dfi <- 
        df_fac |> 
        filter(name == var) |> 
        group_by(name, value) |> 
        summarise(n = n(), .groups = "keep") |> 
        filter(n != 0) |> 
        ungroup()
      
      if (NA %in% dfi$value){
        perc_na <- dfi |> filter(is.na(value)) |> pull(n) / sum(dfi$n)
      } else {
        perc_na <- 0
      }
      
      # If too many factor levels, skip plotting
      if (nrow(dfi) > n_lvls){
        vars_removed <- vars_removed + 1

      # If too many NA, skip plotting
      } else if (perc_na > na_thr){
        vars_removed <- vars_removed + 1
        
      } else {
        factor_plots[[var]] <-  
          dfi |> 
          ggplot() +
          geom_col(aes(y = n, x = value)) +
          xlab(paste(var)) +
          ylab(NULL)
      }
    }
  }
  
  # Numeric Plot
  if (length(numeric_plots) == 0){
    p_num <- NULL
  } else {
    p_num <- numeric_plots[[1]]
    if (length(factor_plots) == 1){
      
    } else {
      for (i in 2:length(numeric_plots)) {
        p_num <- p_num + numeric_plots[[i]]
      }
      p_num + plot_layout(ncol = 4)
    }

  }
  
  # Factor Plot
  if (length(factor_plots) == 0){
    p_fac <- NULL
  } else {
    p_fac <- factor_plots[[1]]
     if (length(factor_plots) == 1){
     } else {
       for (i in 2:length(factor_plots)) {
         p_fac <- p_fac + factor_plots[[i]]
       }
       
       capt <- paste0(
         "Displayed are ",
         n_fact_vars - vars_removed, 
         " of ", n_fact_vars, 
         " factor variables because more the others had either more than ", n_lvls, 
         " factor lvls, or more than ", round(na_thr*100), "% NA. Removed were:\n",
         paste0(fact_vars[1:(n_fact_vars/2)], collapse = ", "), "\n",
         paste0(fact_vars[(n_fact_vars/2):n_fact_vars], collapse = ", "))
       
       p_fac <- 
         p_fac + 
         plot_layout(ncol = 4) + plot_annotation(caption = capt)
         
     }
    }
  
  # Return output
  out <- 
    list(
      p_num = p_num,
      p_fac = p_fac
      )
  
  return(out)
}
```

#### Tree Data

```{r eval=FALSE}
#| layout-nrow: 1
p <- plot_histograms(l_raw_data$arbre)
ggsave("figures/hist_lrawdata_arbre_num.jpg", p$p_num, width = 15, height = 6)
ggsave("figures/hist_lrawdata_arbre_fac.jpg", p$p_fac, width = 15, height = 6)
```

```{r}
#| layout-nrow: 1
knitr::include_graphics("figures/hist_lrawdata_arbre_num.jpg")
knitr::include_graphics("figures/hist_lrawdata_arbre_fac.jpg")
```

#### Location Data

```{r eval=FALSE, message=FALSE, warning=FALSE}
p <- plot_histograms(l_raw_data$placette)
ggsave("figures/hist_lrawdata_loc_num.jpg", p$p_num, width = 15, height = 6)
ggsave("figures/hist_lrawdata_loc_fac.jpg", p$p_fac, width = 15, height = 6)
```

```{r}
#| layout-nrow: 1
knitr::include_graphics("figures/hist_lrawdata_loc_num.jpg")
knitr::include_graphics("figures/hist_lrawdata_loc_fac.jpg")
```

## Data Structure

### Create index

```{r}
#| layout-nrow: 1
idx_comb <- f_get_location_index(l_raw_data)

# Display final structure of index
head(idx_comb)
cat("Dataset holds ", nrow(idx_comb), " sites.")
```

### Sites without Tree Data

Notes:

-   This subset holds all site-years that have no tree data associated with them.

-   This is likely due to sampling tree-less land?

```{r}
#| layout-nrow: 1
# Get index
tmp_idx <- idx_comb |> filter(is.na(n_visits_tre))

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre |> select(idp, a) |> distinct() |> nrow() # Number of trees

cat("\n # Trees: ", n_t,
    "\n # Site-Years: ", n_sy, 
    "\n # Sites: ", n_s,
    "\n   # Sites with two visits: ",            tmp_idx |> filter(!is.na(v1), !is.na(v2)) |> nrow(),
    "\n   # Sites with one first visit only: ",  tmp_idx |> filter(!is.na(v1),  is.na(v2)) |> nrow(),
    "\n   # Sites with one second visit only: ", tmp_idx |> filter(!is.na(v2),  is.na(v1)) |> nrow())
```

```{r}
#| layout-nrow: 1
df_loc |> filter(!is.na(v1), !is.na(v2)) |> pull(v1) |> table() |>
  barplot(main = "Count of sites with no tree data and two visits",
          xlab  = "Year of 1st Visit")

df_loc |> filter(!is.na(v1), is.na(v2)) |> pull(v1) |> table() |>
  barplot(main = "Count of sites with no tree data and one first visit",
          xlab  = "Year of 1st Visit")

df_loc |> filter(is.na(v1), !is.na(v2)) |> pull(v2) |> table() |>
  barplot(main = "Count of sites with no tree data and one second visit",
          xlab  = "Year of 2nd Visit")
```

### 1 Visit & 1 Tree Data

#### Visite == 1

Notes:

-   Sites with location and tree data only gathered once during a first visit but without revisit.

-   2005 - 2016:

    -   Unclear why this data exists. Technically, all sites with first visit between 2005-2016 should have been revisited.

    -   Sites have recorded tree data, so these sites are not just barren land that was not revisited in the old campaign scheme.

    -   These sites might not have been re-visited for different logistic reasons (not enough people to conduct survey, not easily accessible sites, etc.)

-   2017 - 2021: Sites were only visited once so far.

```{r}
#| layout-nrow: 1
# Get index
tmp_idx <- 
  idx_comb |> 
  filter(
    n_visits_tre == 1, # Tree data from only one year
    n_visits_loc == 1, # Location data only from one year
    is.na(v2)          # Only data from first visit
    )

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre  |> select(idp, a) |> distinct() |> nrow() # Number of trees

cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")

cat("\n # of sites with not the same sampling years for trees and location: ",
    df_tre |> filter(v1 != campagne) |> pull(idp) |> unique() |> length())

df_loc$campagne |> table() |> 
  barplot(main = "Count of sites that were not revisited after first visit",
          xlab  = "Year of 1st Visit")
```

```{r}
# Reduce to given year range
yrs <- c(2005, 2016)
df_tre_yr <- df_tre |> filter(between(campagne, yrs[1], yrs[2]))
df_loc_yr <- df_loc |> filter(between(campagne, yrs[1], yrs[2]))

# General info
n_s  <- df_loc_yr |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc_yr |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre_yr |> select(idp, a) |> distinct() |> nrow() # Number of trees

cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")
```

```{r eval=FALSE, warning=FALSE}
p <- plot_histograms(df_tre_yr)
ggsave("figures/hist_df_tre_yr_num.jpg", p$p_num, width = 15, height = 6)
ggsave("figures/hist_df_tre_yr_fac.jpg", p$p_fac, width = 15, height = 6)
```

Tree Data:

```{r}
#| layout-nrow: 1
knitr::include_graphics("figures/hist_df_tre_yr_num.jpg")
knitr::include_graphics("figures/hist_df_tre_yr_fac.jpg")
```

```{r eval=FALSE, warning=FALSE}
p <- plot_histograms(df_loc_yr)
ggsave("figures/hist_df_loc_yr_num.jpg", p$p_num, width = 15, height = 6)
ggsave("figures/hist_df_loc_yr_fac.jpg", p$p_fac, width = 15, height = 6)
```

Location Data:

```{r}
#| layout-nrow: 1
knitr::include_graphics("figures/hist_df_loc_yr_num.jpg")
knitr::include_graphics("figures/hist_df_loc_yr_fac.jpg")
```

#### Visite == 2

Notes:

-   This subset holds sites that have only a second visit but no first visit recorded in the location data

-   Earliest possible campaign to hold this information is 2016 because revisits from 2010-2015 only recorded removals and mortality.

-   This subset shows sites that had no trees measured in the first visit but some trees measured in the second visit. This indicates recruitment of new land.

-   BUT not all trees are that small! Some are just above the c13 threshold of 0.24m, some are much bigger (c13 \> 1). This should not be the case for newly recruited trees?

-   AND it is weird that there should not be any location data measured during the first visit. As shown below, there are revisited sites that hold only information from the second visit, indicating recruitment.

```{r}
#| layout-nrow: 1

# Get index
tmp_idx <- 
  idx_comb |> 
  filter(
    n_visits_tre == 1, # Tree data from only one year
    n_visits_loc == 1, # Location data only from one year
    is.na(v1)          # Only data from second visit
    )

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre |> select(idp, a) |> distinct() |> nrow() # Number of trees
cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")
df_loc$v2 |> table() |> 
  barplot(main = "Count of sites that were visited once but recorded as second visit",
          xlab  = "Year of '2nd Visit'")
df_tre$c13 |> hist(main = "Histogram of c13 measurements", breaks = 50, xlab = "c13 [m]")
```

### 1 Visit & 2 Tree Data

Notes:

-   As expected, there are no sites that were visited only once but have two tree measurements.

```{r}
#| layout-nrow: 1

# Get index
tmp_idx <- idx_comb |> 
  filter(
    n_visits_tre == 2, # Tree data from two years
    n_visits_loc == 1, # Location data only from one year
    )

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre |> select(idp, a) |> distinct() |> nrow() # Number of trees
cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")
```

### 2 Visits & 1 Tree Data

Notes:

-   First visits from 2005 - 2009:

    -   Trees have been re-visited just to check for removal but without re-measurement.

    -   `prevel5` indicates whether none (0), some (1), or all (2). With tree data only recorded once, we have the case of `prelev5 == 0 or 2`. Thus not all tree states are recorded separately but collectively in the location data.

    -   For `prevel5 == 1` cases, the sites are in the "2 Visits & 2 Tree Data" analysis.

-   First visits from 2010 onward:

    -   Trees that were only recorded at second visit -\> recruitment of new trees!

```{r}
#| layout-nrow: 1

# Get index
tmp_idx <- idx_comb |> 
  filter(
    n_visits_tre == 1, # Tree data from only one year
    n_visits_loc == 2, # Location data from two years
    )

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre |> select(idp, a) |> distinct() |> nrow() # Number of trees

cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")

cat("\n # of sites where there were no trees sampled in the first visit: ",
    df_tre |> filter(v1 != campagne) |> pull(idp) |> unique() |> length())

cat("\n # of sites where trees were only sampled in the second visit: ",
    df_tre |> filter(v2 == campagne) |> pull(idp) |> unique() |> length())
```

```{r}
#| layout-nrow: 1
df_loc$v1 |> table() |> 
  barplot(main = "Count of sites with 2 visits but tree data recorded only once",
          xlab  = "Year of 1st Visit")
df_loc$prelev5 |> table()  |> 
  barplot(main = "Count of whether trees were not cut (0), partially cut (1), all cut (2)")
df_loc$nincid |> table()  |> 
  barplot(main = "Type of incident",
          sub  = "0: None, 1: Fire, 2: Mortality, 3: Landslide, 4: Storm, 5: Other")
```

#### 2015 onward

Check assumption whether records from 2015 onward hold newly recruited trees:

```{r}
#| layout-ncol: 2
cat("# Sites: ", tmp_idx |> filter(v1 > 2009) |> nrow())
df_tre |> filter(v1 > 2009) |> pull(c13) |> hist(xlab = "DBH [m]")
```

Most trees are rather small with a c13 of ca. 0.2-0.4m, which could indicate that these are newly recruited trees, and that the respective sites are turning into forests. Nonetheless, there are quite a few large trees that were assessed the first time during the second visit, which is odd.

#### Checking the prelev5 == 1 sites

```{r}
#| layout-ncol: 2
sites <- df_loc |> filter(prelev5 == 1) |> pull(idp) |> as.character()
df_loc |> filter(idp %in% sites) |> arrange(idp)
```

There is no consistent pattern across these few sites. So, we cannot tell which of the trees have been cut and which ones not.

### 2 Visits & 2 Tree Data

Notes:

-   Only for a subset of sites that were first measured after 2005 has been revisited to check the **state** of each tree again. This applies mainly for sites that have been cut partially (`prelev5==1`). For the other sites from 2005-2010, the entire site has been assessed as one.

-   For sites measured after 2010, there is more data available and that data has also measurements of the **size** of each tree.

```{r}
#| layout-nrow: 1

# Get index
tmp_idx <- idx_comb |> 
  filter(
    n_visits_tre == 2, # Tree data from two years
    n_visits_loc == 2, # Location data from two years
    )

# Get data
df_tre <- l_raw_data$arbre    |> inner_join(tmp_idx, by = c("idp"))
df_loc <- l_raw_data$placette |> inner_join(tmp_idx, by = c("idp"))

# General info
n_s  <- df_loc |> select(idp) |> distinct() |> nrow() # Number of sites
n_sy <- df_loc |> select(idp, campagne) |> distinct() |> nrow() # Number of site-years
n_t  <- df_tre |> select(idp, a) |> distinct() |> nrow() # Number of trees

cat("\n # Sites: ", n_s, "  # Site-Years: ", n_sy, "  # Trees: ", n_t, "\n")
df_loc$v1 |> table() |> 
  barplot(main = "Count of sites with 2 visits and trees recorded twice",
          xlab  = "Year of 2nd Visit")
df_loc$prelev5 |> table()  |> 
  barplot(main = "Count of whether trees were not cut (0), partially cut (1), all cut (2)")
```

## Weird Cases

### Site `663945`

Site has no trees recorded at first visit but at second visit. But at second visit, there is also the note that there has been a storm and that "The point suffered an incident less than 5 years ago that affected 25% to 50% of the cover of the trees that can be counted." Does this mean that at second visit, there was a storm that killed off a lot of new trees? **Maybe for such cases, we have to back-calculate how big these trees might have been?**

```{r}
#| layout-ncol: 2
x <- check_idp(663945, FALSE)
datatable(x$arbre, options = list(pageLength = 20))
datatable(x$loc, options = list(pageLength = 2))
```

## Sites with the same coordinates

Notes:

-   Little duplicates are from first visit in 2020, which is odd but probably attributable to the COVID-19 Crisis.
-   A lot of the duplicated sites come from sites that were visited only once (see v2 == NA, or n_visits_loc == 1)
-   Zooming into a few locations on the map shows that often, overlapping sites are due to the chosen sampling design, where the first visit of a new site is planned to be close to the second visit of an old site.
    -   **Important:** If we aggregate data on a location level based on the coordinates, we aggregate multiple stands and therefore get per location a better time-series but we are also mixing sampling campaigns and assume that the sampled site is representative for the entire location. Two sites could be very distinct in their micr-climate, which means that they are not comparable.

```{r}
#| layout-ncol: 3

# Attach coordinate variable
df_xy <-  
  l_raw_data$placette |> 
  mutate(xy = as.factor(paste0(lon, "_", lat)))

# Reduce df to duplicates
df_xy <- 
  df_xy |> 
  select(idp, xy) |> 
  distinct() |> 
  group_by(xy) |> 
  mutate(dupes = n()) |> 
  ungroup() |> 
  arrange(desc(dupes))

# Get subsets
n_all_xy         <- nrow(df_xy)
xy_without_dupes <- df_xy |> filter(dupes == 1)
xy_with_dupes    <- df_xy |> filter(dupes != 1)
perc_no_dupes    <- round(nrow(xy_without_dupes) / n_all_xy * 100)
perc_dupes       <- round(nrow(xy_with_dupes) / n_all_xy * 100)

# Analysis
cat("\n# Total number of individual sites: ", n_all_xy, " ( 100 %)",
    "\n# Number of sites with distinct coordinates: ", nrow(xy_without_dupes), "(", perc_no_dupes, "%)",
    "\n# Number of sites with the same coordinates: ", nrow(xy_with_dupes), "(", perc_dupes, "%)")

# All sites
(df_xy |> pull(dupes) |> table() / n_all_xy ) |> 
  barplot(main = "Duplicated Coordinates",
          xlab = "Number of different sites with the same coordinates \n(`1` denotes sites with distinct coordinates)",
          ylab = "Percentage of all sites [%]")

# Sites with duplicates
(xy_with_dupes |> pull(dupes) |> table() / n_all_xy ) |> 
  barplot(main = "Duplicated Coordinates",
          xlab = "Number of different sites with the same coordinates",
          ylab = "Percentage of all sites [%]")

# Print histogram with high-level data
xy_with_dupes <- xy_with_dupes |> left_join(idx_comb)
p <- plot_histograms(
  xy_with_dupes |> 
    mutate_if(is.numeric, as.factor))
p$p_fac
```

```{r}
# Create leaflet map for investigation
# Attach coords
xy_with_dupes <- 
  xy_with_dupes |> 
  left_join(l_raw_data$placette |> select(idp, lat, lon) |> distinct())

require(leaflet)

leaflet() |> 
  # As base maps, use two provided by ESRI
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  # addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") |>
  # addProviderTiles(providers$Esri.WorldTopoMap, group = "World Topo") |>
  
  # Add markers for sampling locations
  leaflet::addMarkers(
    data = xy_with_dupes,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~paste("ID:", idp,
                   "<br>| # Dupes:", dupes, 
                   "<br>| Visit 1:", v1, 
                   "<br>| Visit 2:", v2, 
                   "<br>| N tree data:", n_visits_tre
                   ),
    clusterOptions = markerClusterOptions()
  )
```

```{r}
knitr::knit_exit()
```

# NO RENDER BELOW ---

# Old - Data Structure

```{r}
# Get temporary df
df_tmp  <- l_raw_data$placette

# Get total number of locations
n_plots <- df_tmp |> pull(idp) |> unique() |> length()

# Get locations with visit == 1
idp_1visit <- df_tmp |> filter(visite == 1) |> pull(idp) |> unique()

# Get locations with visit == 2
idp_2visit <- df_tmp |> filter(visite == 2) |> pull(idp) |> unique()

# Get locations with only a first or only a second visit
n_only_v1  <- df_tmp |> filter(visite == 1, !idp %in% idp_2visit)
n_only_v2  <- df_tmp |> filter(visite == 2, !idp %in% idp_1visit)

# Variables for later use
loc_only_v1 <- n_only_v1
loc_only_v2 <- n_only_v2

# Get table with # of visits and re-visits
tab_visits <- l_raw_data$placette |> pull(visite) |> table()
```

```{r}
# Print results
cat("\n # All entries:  ", n_plots,
    "\n # Entries with visite == 1: ", tab_visits[[1]],
    "\n # Entries with visite == 2: ", tab_visits[[2]],
    "\n   = Revisit rate:  ", round(tab_visits[[2]] / tab_visits[[1]] * 100, 0), "%",
    "\n # Entries without 2nd visit: ", nrow(n_only_v1), 
    "(", round(nrow(n_only_v1) / n_plots * 100, 2), "% )",
    "\n # Entries with only 2nd visit: ", nrow(n_only_v2),
    "(", round(nrow(n_only_v2) / n_plots * 100, 2), "% )")

cat("\n -------------------------------------------------------\n")

# What are the campaigns where only one or only a second visit was entered?
cat("\n > Table of Campagnes of Sites without second visit :\n")
table(n_only_v1$campagne)

cat("\n > Table of Campagnes of Sites with only second visit :\n")
table(n_only_v2$campagne)

cat("\n > Table of Departments of Sites with only second visit :\n")
table(n_only_v2$dep)[table(n_only_v2$dep) > 0]

```

Can we confirm this table with the tree-level data? Note that unlike for the location data, we do not have explicit information on the visit. We only have information on whether a tree was visited once or twice.

```{r}
# Get total number of visits per location
df_all <- 
  l_raw_data$arbre |> 
  select(idp, campagne) |> 
  distinct() |> 
  group_by(idp) |> 
  mutate(visits = n())

n_plots <- nrow(df_all)  
  
# Split dfs into locations with one and two visit(s)
df_v1 <- df_all |> filter(visits == 1)
df_v2 <- df_all |> filter(visits == 2)

# Print results
cat("\n # Entries in total:  ", n_plots,
    "\n # Entries with 1 Visit:  ", nrow(df_v1), 
    " (", round(nrow(df_v1)/n_plots*100) ,"% of total)",
    "\n # Entries with 2 Visits: ", nrow(df_v2), 
    " (", round(nrow(df_v2)/n_plots*100) ,"% of total)")
```

The numbers from the tree-lvl data does not really match the location-lvl data. Looking at the data separately showed that the location and tree data does not align 100%. For example, there are revisits stated in the location data for which there were no tree measurements. Let's dive into this further:

## All possible cases

+------------+------------------------------------------------------------------------------------------+---------+
| Case - Nr. | Case                                                                                     | IDP     |
+============+==========================================================================================+=========+
| 1          | ONE visit, recorded as `visit == 1` AND tree data from that visit                        | 36942   |
+------------+------------------------------------------------------------------------------------------+---------+
| 4          | ONE visit, recorded as `visit == 2` AND tree data from that visit                        | 605994  |
+------------+------------------------------------------------------------------------------------------+---------+
| 2          | ONE visit, recorded as `visit == 1` AND tree data from two visits                        | NONE    |
+------------+------------------------------------------------------------------------------------------+---------+
| 3          | ONE visit, recorded as `visit == 1` AND NO tree data from that visit                     | 126     |
+------------+------------------------------------------------------------------------------------------+---------+
| 4          | ONE visit, recorded as `visit == 2` AND NO tree data from that visit                     | 10000   |
+------------+------------------------------------------------------------------------------------------+---------+
| 5          | TWO visits with all first trees recorded again AND WITHOUT new trees recruited           | 1106469 |
+------------+------------------------------------------------------------------------------------------+---------+
| 6          | TWO visits with all first trees recorded again AND WITH new trees recruited              | 1125552 |
+------------+------------------------------------------------------------------------------------------+---------+
| 7          | TWO visits with NOT all first-visit-trees recorded again AND WITHOUT new trees recruited | 179     |
+------------+------------------------------------------------------------------------------------------+---------+
| 8          | TWO visits with NOT all first-visit-trees recorded again AND WITH new trees recruited    | NONE    |
+------------+------------------------------------------------------------------------------------------+---------+
| 9          | TWO visits with NO first-visit-trees AND WITH new trees recruited at second visit        | 1100040 |
+------------+------------------------------------------------------------------------------------------+---------+
| 10         | TWO visits with tree data only from first visit                                          | 19      |
+------------+------------------------------------------------------------------------------------------+---------+
| 10         | TWO visits but with no tree data on both visits                                          | 1000482 |
+------------+------------------------------------------------------------------------------------------+---------+

# old

```{r eval=FALSE}
# Get spaced subset with 2 sites per year
tmp_idx <- tmp_idx <- idx_comb |> filter(n_visits_tre == 1, n_visits_loc == 2)

# Get data
df_tre <- l_raw_data$arbre    |> filter(idp %in% tmp_idx$idp)
df_loc <- l_raw_data$placette |> filter(idp %in% tmp_idx$idp)

# Summary
table(df_tre$campagne)
table(df_loc$prelev5)

# Sites that were only a subset was cut
tmp_idx <- df_loc |> filter(prelev5 == 1)
l_raw_data$arbre    |> filter(idp %in% tmp_idx$idp)

```

```{r eval=FALSE}
# Quick access
n_sites <- c(3686, 52026, 14734, 309724)
n_sites <- tmp_idx

for (n in n_sites) {
  l_raw_data$arbre    |> filter(idp == n) |> print(n = 50)
  l_raw_data$placette |> filter(idp == n) |> print(n = 50)
}
```

```{r eval=FALSE}
n <- 
l_raw_data$arbre    |> filter(idp == n)
l_raw_data$placette |> filter(idp == n)
```

------------------------------------------------------------------------

```{r eval=FALSE}
# Get number of visits index
# Taking location data as source of truth for whether the campaign was the first
# or second visit because there might have been no trees recorded in the first 
# visit but newly grown trees in the second visit.
idx_loc <- l_raw_data$placette |> select(idp, campagne, visite)

# Also get a "number of visits" index from the tree data to check for edge cases
idx_tre <- 
  l_raw_data$placette |> 
  select(idp, campagne) |> 
  distinct() |> 
  group_by(idp) |> 
  mutate(n_visits = n()) |> 
  ungroup()

# The code below does the following steps:
# - It joins the visits index to translate the campagne number to the visit nmb 
#   (could also be done through attaching the location information, but then
#   we have the issue of potentially not having two visits but only a false
#   visit = 2 entry).
# - The df is widened to have one row per tree (some variables are needlessly
#   duplicated but this can be cleaned later, see `fixed_vars`)
# - The widened df, is then mutated to count the trees in the first and second
#   visit and to check whether the same amount of trees was sampled, whether
#   some trees were not recorded again in second visit (lost),
#   and whether there were new trees counted in the second visit (= recruitment).

# Define a function to compare nested lists in a dataframe
count_x_not_in_y <- function(x, y){sum(!x %in% y)}

# Define variables that stay fixed (incomplete list for now, 2023-08-03)
fixed_vars <- c("idp", "a")

# Debug: Edge cases to see if code works
edge_cases <- c(19, 1125552, 1100040, 605994, 179, 1106469)

# Wrangle dataframe
df_treecount <-
  l_raw_data$arbre |> 
  right_join(idx_loc, by = c("idp", "campagne")) |> 
  pivot_wider(names_from = visite, values_from = -all_of(fixed_vars)) |> 
  group_by(idp) |> 
  nest() |> 
  
  ## Deubg slices
  ## Specific sites
  # filter(idp == 1100040) |> 
  # filter(idp == 605994) |> 
  # filter(idp == 19) |>
  
  # Edge cases
  # filter(idp %in% edge_cases) |> 
  
  ## Random Subset
  # ungroup() |>
  # slice(as.integer(runif(n=50, min=1, max=100000))) |>
  # group_by(idp) |>
  
  ##
  mutate(trees_v1    = map(data, ~filter(., 
                                         !is.na(campagne_1), 
                                         !is.na(a)) |> pull(a)),
         trees_v2    = map(data, ~filter(., 
                                         !is.na(campagne_2), 
                                         !is.na(a)) |> pull(a)),
         n_trees_v1  = length(unlist(trees_v1)),
         n_trees_v2  = length(unlist(trees_v2)),
         n_missing   = map2_dbl(trees_v1, trees_v2, count_x_not_in_y),
         n_recruited = map2_dbl(trees_v2, trees_v1, count_x_not_in_y)
         # , 
         # campagne_1  = map_dbl(data, 
         #                       ~filter(!is.na(a), 
         #                               !is.na(campagne_1)) |> 
         #                         pull(campagne_2) |> 
         #                         unique()),
         # campagne_2  = map_dbl(data, 
         #                       ~filter(!is.na(a), 
         #                               !is.na(campagne_1)) |> 
         #                         pull(campagne_2) |> 
         #                         unique())
         ) |> 
  select(-trees_v1, -trees_v2) |> 
  ungroup()

head(df_treecount |> arrange(desc(n_recruited)))
```

```{r eval=FALSE}
# Sub-sample of only revisited sites and getting metrics
df_2visits <- df_treecount |> filter(!is.na(campagne_1), !is.na(campagne_2))
sum_trees_v1        <- sum(df_2visits$n_trees_v1)
sum_trees_v2        <- sum(df_2visits$n_trees_v2)
sum_trees_missing   <- sum(df_2visits$n_missing)
sum_trees_recruited <- sum(df_2visits$n_recruited)

perc_missing   <- round( sum_trees_missing / sum_trees_v1 * 100)
perc_recruited <- round( sum_trees_recruited / sum_trees_v2 * 100)
```

```{r eval=FALSE}
# Print some results
cat("\n Nr. of sites: ", nrow(df_treecount), "( 100 % )",
    "\n  Without revisit: ", nrow(df_treecount |> filter(is.na(campagne_2))),
    "(", round(nrow(df_treecount |> filter(is.na(campagne_2))) / nrow(df_treecount) * 100), "% )", 
    "\n  With    revisit: ", nrow(df_treecount |> filter(!is.na(campagne_2))),
    "(", round(nrow(df_treecount |> filter(!is.na(campagne_2))) / nrow(df_treecount) * 100), "% )",
    "\n --- ",
    "\n From sites that were revisited: ",
    "\n  Nr. of revisited trees: ", sum_trees_v2 - sum_trees_recruited, "( 100 % )",
    "\n  Nr. of trees that went missing: ", sum_trees_missing, "(", perc_missing ,"% )",
    "\n  Nr. of newly recruited trees: ", sum_trees_recruited, "(", perc_recruited ,"% )")
```

```{r eval=FALSE}
# From 2nd visits, how often were trees not found anymore?
df_2visits |> 
  select(n_missing, campagne_2) |> 
  group_by(campagne_2) |> 
  summarise(sum_missing = sum(n_missing)) |> 
  ggplot(aes(campagne_2, sum_missing)) +
  geom_point() +
  geom_line() +
  ggtitle(
    paste0("Missing: Numer of trees that were not recorded during 2nd visit: ", 
           sum_trees_missing, " (", perc_missing,"%)")
    )
```

```{r eval=FALSE}
# From 2nd visits, how often were new trees recruited?
df_treecount |> 
  filter(!is.na(campagne_2)) |> 
  select(n_recruited, campagne_2) |> 
  group_by(campagne_2) |> 
  summarise(sum_recruited = sum(n_recruited)) |> 
  ggplot(aes(campagne_2, sum_recruited)) +
  geom_point() +
  geom_line() +
  ggtitle(
    paste0("Recruitment: Numer of trees that were newly recorded during 2nd visit: ", 
           sum_trees_recruited, " (", perc_recruited,"%)")
    )
```

```{r eval=FALSE}
# Check: Why are there revisited sites in the location data that are not
# in the tree data?

# Look at the time the data comes from
df_tmp <- l_raw_data$placette |> filter(visite == 2)
sites_revisited_only_in_df_loc <- df_tmp |> filter(!idp %in% df_2visits$idp)
hist(sites_revisited_only_in_df_loc$campagne)

sites_revisited_only_in_df_loc


# Sites that have only a second visit in the location data but not in the tree data
table(loc_only_v2$idp %in% df_tmp$idp)
loc_only_v2$idp[!(loc_only_v2$idp %in% df_tmp$idp)]
```

## Sites with identical coordinates

# Maps

## France

```{r eval=FALSE}
# Next, we build a leaflet map
leaflet() |> 
  # As base maps, use two provided by ESRI
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  # addProviderTiles(providers$Esri.WorldImagery, group = "World Imagery") |>
  # addProviderTiles(providers$Esri.WorldTopoMap, group = "World Topo") |>
  
  # Add markers for sampling locations
  leaflet::addMarkers(
    data = l_raw_data$placette,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~as.character(dep),
    clusterOptions = markerClusterOptions()
  )
```

## Sub-Region

```{r eval=FALSE}
# Define coordinates for subregion
l_subreg <- list(
  min_lon = 5.542038,
  max_lon = 6.917511,
  min_lat = 45.005973,
  max_lat = 45.556079
)

# Filter sites for subregion
df_loc <- 
  l_raw_data$placette |> 
  dplyr::filter(between(lon, l_subreg$min_lon, l_subreg$max_lon),
                between(lat, l_subreg$min_lat, l_subreg$max_lat))

leaflet() |> 
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  leaflet::addMarkers(
    data = df_loc,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~paste("ID:", idp, "| Campagne:", campagne),
    clusterOptions = markerClusterOptions()
  ) |>
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    fillColor = "transparent"
  )
```

# Analysis of Sub-Region

## Data Filter Criteria

1.  Remove sites that have only a first but no second visit.
2.  Remove sites that have only a second but no first visit

-   or investigate if we can match them)

3.  Remove sites that were sampled twice but where less trees were recorded in the second round.

-   or investigate if trees that were certainly recorded can be matched

## Vegetation State Levels

```{r eval=FALSE}
raw_lvls |> 
  filter(str_detect(variable, "^VEGET5")) |> 
  arrange(lvl) |> 
  knitr::kable()
```

TODO: There are no lvls saved for 'VEGET', so I am guessing that those are the same as for 'VEGET5'. However, there is a 'VEGET' = 'Z' for which I cannot find any explanation.

```{r eval=FALSE}
lvl_alive <- c("0", "1")
lvl_dead  <- c("2", "5", "A", "C", "M", "T")
lvl_cut   <- c("6", "7")
lvl_na    <- c("N", NA)
```

## Get subset of tree data

```{r eval=FALSE}
# For easy access here, get subset again
df_loc <- 
  l_raw_data$placette |> 
  dplyr::filter(
    between(lon, l_subreg$min_lon, l_subreg$max_lon),
    between(lat, l_subreg$min_lat, l_subreg$max_lat)
    )

# Get tree and location dfs
id_subset <- df_loc |> pull(idp)
df_tre    <- 
  l_raw_data$arbre |> 
  filter(idp %in% id_subset)

# Attach status variable
df_tre <- 
  df_tre |> 
  mutate(status  = NA) |> 
  mutate(status5 = NA) |> 
  mutate(
    # First visit
    status  = ifelse(veget  %in% lvl_alive, "0", status),
    status  = ifelse(veget  %in% lvl_dead , "1", status),
    status  = ifelse(veget  %in% lvl_cut  , "2", status),
    status  = ifelse(veget  %in% lvl_na   ,  NA, status),
    
    # Second visit
    status5 = ifelse(veget5 %in% lvl_alive, "0", status5),
    status5 = ifelse(veget5 %in% lvl_dead , "1", status5),
    status5 = ifelse(veget5 %in% lvl_cut  , "2", status5),
    status5 = ifelse(veget5 %in% lvl_na   ,  NA, status5),
    
    # Most recent visit
    status_recent = ifelse(!is.na(status5), status5, status)
  )

# DEBUG FOR SIMPLER DATAFRAMES
df_tre <- df_tre |> select(campagne, idp, a, contains("veget"), contains("status"), c13)
df_loc <- df_loc |> select(campagne, idp, visite, lat, lon)

# Join dataframes
df_join <- 
  left_join(
    df_tre,
    df_loc,
    by = c("campagne", "idp")
  )
```

```{r}
# # Create long-pivot for easier computations
# # 1. Add vis variable for pivot_wide
# df_join <- 
#   df_join |> 
#   mutate(vis = ifelse(visite == 1, paste0("v1"), paste0("v2")))
# 
# # 2. Select variables not to pivot (extendable later on)
# vars_no_pivot <- 
#   c("idp", "vis", "idp", "a",
#     # "lon_fr", "lat_fr", "lon", "lat", 
#     "dep", "ser"
#     )
# 
# vars_to_pivot <- df_join |> select(-all_of(vars_no_pivot)) |> names()
# 
# # Pivot wide
# df_wide <- 
#   df_join |> 
#   pivot_wider(names_from = vis, 
#               values_from = any_of(vars_to_pivot))
# 
# # Drop widened variables that have only NA in them
# df_wide <- df_wide |> select(where(~!all(is.na(.))))

# Aggregate to stand level
# df_stand <- df_wide |> group_by(idp) |> nest()
```

## Current Forest State

Check for the current state of forests (alive/dead/cut). That means, for each of the latest visits of a plot, we want to know its state.

```{r eval=FALSE}
# Nest dataframe by site and campaign
df_stand <- df_join |> group_by(idp, campagne) |> nest()

# For each site-campaign, record the most recent tree status
df_agg <- 
  df_stand |> 
  mutate(n_tree = purrr::map_dbl(data, ~nrow(.)),
         agg    = purrr::map(data, 
                             ~. |> 
                               group_by(status_recent) |> 
                               count() |> 
                               pivot_wider(names_from = status_recent, 
                                           values_from = n))
         ) |> 
  unnest(agg) |> 
  rename(
    n_alive = `0`,
    n_dead  = `1`,
    n_cut   = `2`,
    n_na    = `NA`,
  ) 

# For each site-campaign, calculate the percentage of tree status
# Set sites with NA values to 0 because it meant that there was no count.
df_agg <- 
  df_agg |> 
  mutate(
    perc_alive = n_alive / n_tree, 
    perc_dead  = n_dead  / n_tree, 
    perc_cut   = n_cut   / n_tree,   
    perc_na    = n_na    / n_tree   
  ) |> 
  mutate(
    across(contains("n_"), ~ifelse(is.na(.), 0, .)),
    across(contains("perc_"), ~ifelse(is.na(.), 0, .)))

# Quality control: All percentages should equal 1 (with small rounding error)
qc_check <- 
  df_agg |> 
  mutate(qc = perc_alive + perc_dead + perc_na + perc_cut,
         qc = round(qc, 3)) |> 
  filter(qc != 1) |> 
  nrow()

if (qc_check != 0) {stop("QC for tree percentages failed!")}

# For re-visits, keep only the latest data
df_status <- 
  df_agg |>
  ungroup() |>
  select(campagne, idp, contains("perc")) |>
  pivot_longer(cols = contains("perc"), 
               names_to = "status", 
               values_to = "perc") |>
  arrange(desc(campagne), desc(perc)) |>
  group_by(idp) |>
  slice(1) |>
  mutate(status = str_remove(status, "perc_"),
         status = as.factor(status)) |> 
  ungroup()

# Attach coordinates
df_status <- 
  df_status |>
  left_join(df_loc |> select(idp, lat, lon) |> distinct(), by = "idp")
```

## Forest State of Subset

```{r eval=FALSE}
# Code adapted from: 
# https://stackoverflow.com/questions/35921590/leaflet-on-r-how-to-create-layers-and-colors-for-each-factor-level-in-dataframe

groups     <-  as.character(unique(df_status$status))
groups_col <-  colorFactor(palette = "viridis", 
                           domain = df_status$status)

map <- 
  leaflet(df_status) |> 
  addProviderTiles(
    providers$Esri.WorldImagery,
    group = "World Imagery") |>
  addProviderTiles(
    providers$Esri.WorldTopoMap, 
    group = "World Topo")

for (g in groups){
  df_i <-  df_status |> filter(status == g)
  
  map <- 
    map |> 
    addCircleMarkers(
      data = df_i, 
      lng = ~lon, 
      lat = ~lat, 
      color = ~groups_col(status),
      group = g, 
      label = ~paste("Status: ", status, 
                     "| Year: ", campagne,
                     "| Perc.: ", round(perc, 2),
                     "| IDP: ", idp),
      opacity = 0.9)

}

map |> 
  addLayersControl(
    overlayGroups = groups,
    baseGroups = c("World Imagery", "World Topo"),
    position = "topleft",
    options = layersControlOptions(collapsed = FALSE)) |> 
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    color = "black",
    fillColor = "transparent",
    opacity = 1
  ) |> 
  addLegend(
    pal = groups_col,
    values = groups,
    title = "Stand Status",
    position = "topleft")
```

IDP: 23803 XL 685643.6379000925 YL 6760725.288768466

IDP: 519963 XL 988815.4102918436 YL 6458378.306485492

```{r eval=FALSE}
leaflet() |> 
  addProviderTiles("OpenStreetMap.Mapnik") |> 
  leaflet::addMarkers(
    data = df_status,
    lng = ~lon,  # Column name for x coordinates
    lat = ~lat,  # Column name for y coordinates
    popup = ~paste("Status:", status, "| Perc.:", round(perc, 2)),
    group = ~status
    # clusterOptions = markerClusterOptions()
  ) |>
  addRectangles(
    lng1 = l_subreg$min_lon, 
    lat1 = l_subreg$min_lat,
    lng2 = l_subreg$max_lon, 
    lat2 = l_subreg$max_lat,
    fillColor = "transparent"
  )
```

```{r eval=FALSE}
# DROPPED: 2023-07-28 Worked on getting the forest state from the wide df
# but the realised than not widening might be easier...
# Attach number of trees visited at first and at second visit
df_tmp <- 
  df_stand |> 
  dplyr::mutate(
    ntree_v1 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v1)))),
    ntree_v2 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v2))))
  )

# Get subset with and without revisits WORKING: SEE END OF THIS CHUNK FIRST 
# df_revisit_yes <- df_tmp |> filter(ntree_v2 != 0)
# df_revisit_no  <- df_tmp |> filter(ntree_v2 == 0)

# Filter the weird case, 
df_revisit_yes <- df_tmp |> filter(ntree_v2 != 0)
df_revisit_no  <- df_tmp |> filter(ntree_v2 == 0)
df_revisit_par <- df_tmp |> filter(between(ntree_v2, 1, ntree_v1-1))

# At each site, extract status information from latest visit
df_revisit_yes <- 
  df_revisit_yes |> 
  mutate(n_alive = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 0))),
         n_dead  = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 1))),
         n_cut   = purrr::map_dbl(data, ~nrow(filter(., status5_v2 == 2))),
         n_na    = purrr::map_dbl(data, ~nrow(filter(., is.na(status_v2)))),
         p_alive = n_alive / ntree_v2,
         p_dead  = n_dead  / ntree_v2,
         p_cut   = n_cut   / ntree_v2,
         p_na    = n_na    / ntree_v2
         )

df_revisit_no <- 
  df_revisit_no |> 
  mutate(n_alive = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 0))),
         n_dead  = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 1))),
         n_cut   = purrr::map_dbl(data, ~nrow(filter(., status_v1 == 2))),
         n_na    = purrr::map_dbl(data, ~nrow(filter(., is.na(status_v1)))),
         p_alive = n_alive / ntree_v1,
         p_dead  = n_dead  / ntree_v1,
         p_cut   = n_cut   / ntree_v1,
         p_na    = n_na    / ntree_v1
         )

# Investigate plots where there have been more trees visited at the first
# than at the second visit -> that should not be the case!
xxx <- 
  df_revisit_yes |> 
  filter(ntree_v1 > ntree_v2) |> 
  mutate(
    yr1 = purrr::map_dbl(
      data, ~filter(., !is.na(campagne_v1)) |> pull(campagne_v1) |> unique()),
    yr2 = purrr::map_dbl(
      data, ~filter(., !is.na(campagne_v2)) |> pull(campagne_v2) |> unique())
  )
```

## Quality Control of Subset

```{r eval=FALSE}
# 1. Check for stands that have not been revisited, where ntree_v2 == 0
df_no_revisit <- df_stand |> filter(ntree_v2 == 0)

# Since all trees are re-visited, there should never be more trees recorded
# in the first visit than in the second visit. Let's see if this is the case:
df_qc <- 
  df_stand |> 
  mutate(qc = ntree_v1/ntree_v2) |> 
  filter(qc > 1)

df_qc
```

## Tree State Percentages

TODO: Question. What about trees that have been dead at the first visit already?

TODO: What about a change in mortality? Then, I would need to have the perc_dead in the first visit and the per_dead in the second visit, right?

TODO: Probably have to add some quality control to filter out plots that were visited only once.

TODO: I am a bit confused about how the counting should were in such temporal data. For example, if a new tree grows. Then in the old plot there were 10 and now 11. So, there is an increase in 10%. But, if another tree died, there is a growth of 10%, a decline of 10%, and no change in the number of trees.

Method:

-   Percentage at first visit: Calculate all trees

```{r eval=FALSE}
xxx <- 
  df_stand |> 
  dplyr::mutate(
    ntree_v1 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v1)))),
    ntree_v2 = purrr::map_dbl(data, ~nrow(filter(., !is.na(campagne_v2))))
  )



xxx <- 
  df_stand |> 
  dplyr::mutate(
    
    # MORTALITY
    perc_dead_v1 = purrr::map_dbl(
      data,
      ~nrow(filter(., status_v1 == 1 & !is.na(campagne_v1))) / 
        nrow(filter(., !is.na(campagne_v1))))
      ),
    perc_dead_v2 = purrr::map_dbl(
      data,
      ~nrow(filter(., status_v2 == 1))/ nrow()
      ),
    
    # REMOVAL / CUT
    perc_rem_v1 = purrr::map_dbl(
      data,
      ~filter(., status_v1 == 2) |> nrow() / nrow(.)
      ),
    perc_rem_v2 = purrr::map_dbl(
      data,
      ~filter(., status5_v2 == 2) |> nrow() / nrow(.)
      ),
    
    # ALIVE
    perc_rem_v1 = purrr::map_dbl(
      data,
      ~filter(., status_v1 == 2) |> nrow() / nrow(.)
      ),
    perc_rem_v2 = purrr::map_dbl(
      data,
      ~filter(., status5_v2 == 2) |> nrow() / nrow(.)
      ),
  )
```

## Tree Mortality and Removal

### Tree Mortality

```{r eval=FALSE}
xxx <- df_tre$data[[999]]
x   <- xxx |> select(-campagne, -a) |> names()

yyy <- xxx |> pivot_longer(
  cols = all_of(x),
  
)
```

## Forest Growth

## *Definition of Forest Growth:*

### Revisited Trees

### New Recruitment
